{
  "README.html": {
    "href": "README.html",
    "title": "Li/onk Core | Lionk",
    "keywords": "Li/onk Core ‚ó¶ Connecting Components Seamlessly! üìñ Table of Contents üìç Overview üöÄ Getting Started üîß Installation ü§ñ Running Li/onk Core ü§ù Contributing üìç Overview Li/onk Core is a modular platform developed in .NET designed to enable the management and integration of various components through plugins. The project is crafted to cater to end users (operators and administrators) as well as plugin developers, offering maximum flexibility and extensibility. The primary goal is to enhance the quality of life in home environments by allowing seamless integration and management of various components. The application provides a web interface for configuring components and visualizing data. Users can easily add new plugins to define additional components. The application is published as a Docker image for easy deployment, with each release also publishing new NuGet packages to facilitate plugin development. Key Features: Dashboard Data Consultation: Users can continuously monitor component-specific data through an up-to-date dashboard. Alarm Management: Users receive notifications for system failures or specific component alerts, with options for email or push notifications. Remote Access: The application is accessible remotely via a web browser. Application Configuration: Administrators can configure the application, add or remove components, and link components together. Plugin Integration: Administrators can integrate, activate, or deactivate third-party plugins. User Management: Administrators can manage users and roles within the application. Data Management: Administrators can export and delete component-collected data in JSON format. Plugin Development: Developers have access to comprehensive documentation and SDKs for creating compatible plugins. Example Use Case: Boiler Room Control Integration Energy Storage: Administrators can manage energy storage from a living room chimney. Temperature Optimization: The system optimizes heat flow based on storage temperatures using a 3-way valve. Auto-Regulation: The system auto-regulates based on the chimney's temperature. System Alerts: Notifications are sent if the system fails or if temperatures exceed certain thresholds. Li/onk Core aims to provide a comprehensive and flexible solution for managing and integrating various components, ensuring seamless operation and extensibility. üöÄ Getting Started Detailed instructions for getting started with Li/onk Core will be provided soon. üîß Installation Instructions for installing Li/onk Core will be provided soon. ü§ñ Running Li/onk Core Instructions for running Li/onk Core will be provided soon. ü§ù Contributing Contributions are welcome! Here are several ways you can contribute: Join the Discussions: Share your insights, provide feedback, or ask questions. Report Issues: Submit bugs or log feature requests. Develop New Plugins: The best way to contribute is by extending the possibilities of the application using our NuGet packages to develop new plugins."
  },
  "api/Lionk.Auth.Abstraction.IUserRepository.html": {
    "href": "api/Lionk.Auth.Abstraction.IUserRepository.html",
    "title": "Interface IUserRepository | Lionk",
    "keywords": "Interface IUserRepository Namespace Lionk.Auth.Abstraction Assembly Lionk.Auth.dll This interface is used to manage the storage of users. public interface IUserRepository Methods DeleteUser(User) Method to delete a user. void DeleteUser(User id) Parameters id User The id of the user to delete. GetUsers() Method to get a HashSet<T> of all the users. HashSet<User> GetUsers() Returns HashSet<User> A HashSet<T> of all the users. SaveUser(User) Method to save a user. void SaveUser(User user) Parameters user User The user to save. UpdateUser(User) Method to update a user. void UpdateUser(User user) Parameters user User The user to update."
  },
  "api/Lionk.Auth.Abstraction.IUserService.html": {
    "href": "api/Lionk.Auth.Abstraction.IUserService.html",
    "title": "Interface IUserService | Lionk",
    "keywords": "Interface IUserService Namespace Lionk.Auth.Abstraction Assembly Lionk.Auth.dll Service to manage users. public interface IUserService Properties UserRepository Gets or sets the user repository. IUserRepository UserRepository { get; set; } Property Value IUserRepository Methods Delete(User) Method to delete a user. bool Delete(User id) Parameters id User The user to delete. Returns bool True if the user was deleted, false otherwise. GetRegisteredUser(string, string) Method to get a registered user. User? GetRegisteredUser(string username, string passwordHash) Parameters username string The username of the user. passwordHash string The hash of the password of the user. Returns User The registered user. GetUserByEmail(string) Method to get a user by its email. User? GetUserByEmail(string email) Parameters email string The email of the user. Returns User The user with the email, null if not found. GetUserById(Guid) Method to get a user by its id. User? GetUserById(Guid id) Parameters id Guid The id of the user. Returns User The user with the id, null if not found. GetUserByUsername(string) Method to get a user by its username. User? GetUserByUsername(string username) Parameters username string The username of the user. Returns User The user with the username, null if not found. GetUserSalt(string) Method to get the salt of a user. string GetUserSalt(string username) Parameters username string The username of the user. Returns string The salt of the user. GetUsers() Method to get all the users. HashSet<User> GetUsers() Returns HashSet<User> The hashSet of all the users. Insert(User) Method to insert a user. User? Insert(User user) Parameters user User The user to insert. Returns User The inserted user, null the insertion failed. IsEmailExist(string) Method to check if a username exists. bool IsEmailExist(string email) Parameters email string The user to check. Returns bool True if the username exists, false otherwise. IsFirstUserRegistered() Method to check if the current user being registered is the first user in the system. If true, this indicates that the user should be assigned the Admin role. bool IsFirstUserRegistered() Returns bool True if the current user is the first to be registered, false otherwise. IsIdExist(Guid) Method to check if an id exists. bool IsIdExist(Guid id) Parameters id Guid The user to check. Returns bool True if the id exists, false otherwise. IsUsernameExist(string) Method to check if a username exists. bool IsUsernameExist(string username) Parameters username string The user to check. Returns bool True if the username exists, false otherwise. Update(User) Method to update a user. User? Update(User user) Parameters user User The user to update. Returns User The updated user, null if the update failed."
  },
  "api/Lionk.Auth.Abstraction.html": {
    "href": "api/Lionk.Auth.Abstraction.html",
    "title": "Namespace Lionk.Auth.Abstraction | Lionk",
    "keywords": "Namespace Lionk.Auth.Abstraction Interfaces IUserRepository This interface is used to manage the storage of users. IUserService Service to manage users."
  },
  "api/Lionk.Auth.Identity.User.html": {
    "href": "api/Lionk.Auth.Identity.User.html",
    "title": "Class User | Lionk",
    "keywords": "Class User Namespace Lionk.Auth.Identity Assembly Lionk.Auth.dll This class represents a user. public class User Inheritance object User Inherited Members object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors User(Guid, string, string, string, string, List<string>) Initializes a new instance of the User class. [JsonConstructor] public User(Guid id, string userName, string email, string passwordHash, string salt, List<string> roles) Parameters id Guid The unique identifier of the user. userName string The username of the user. email string The email of the user. passwordHash string The password hash of the user. salt string The salt used to hash the password. roles List<string> The roles of the user. User(string, string, string, string, List<string>) Initializes a new instance of the User class. public User(string userName, string email, string passwordHash, string salt, List<string> roles) Parameters userName string The username of the user. email string The email of the user. passwordHash string The password hash of the user. salt string The salt used to hash the password. roles List<string> The roles of the user. Properties Email Gets the email of the user. public string Email { get; } Property Value string Id Gets the unique identifier of the user. public Guid Id { get; } Property Value Guid PasswordHash Gets the password hash of the user. public string PasswordHash { get; } Property Value string Roles Gets the roles of the user. public IReadOnlyCollection<string> Roles { get; } Property Value IReadOnlyCollection<string> Salt Gets the salt used to hash the password. public string Salt { get; } Property Value string Username Gets the username of the user. public string Username { get; } Property Value string Methods AddRole(string) Method to add a role to the user. public void AddRole(string role) Parameters role string The role to add. AddRoles(IEnumerable<string>) Method to add roles to the user. public void AddRoles(IEnumerable<string> roles) Parameters roles IEnumerable<string> The roles to add. Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. FromClaimsPrincipal(ClaimsPrincipal) Method to convert a ClaimsPrincipal to a user. public static User FromClaimsPrincipal(ClaimsPrincipal principal) Parameters principal ClaimsPrincipal The ClaimsPrincipal to convert. Returns User The user from the ClaimsPrincipal. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. RemoveRole(string) Method to remove a role from the user. public void RemoveRole(string role) Parameters role string The role to remove. RemoveRoles(IEnumerable<string>) Method to remove roles from the user. public void RemoveRoles(IEnumerable<string> roles) Parameters roles IEnumerable<string> The roles to remove. ToClaimsPrincipal() Method to convert the user to a ClaimsPrincipal. public ClaimsPrincipal ToClaimsPrincipal() Returns ClaimsPrincipal The user as a ClaimsPrincipal. UpdateEmail(string) Method to update the email of the user. public void UpdateEmail(string newEmail) Parameters newEmail string The new email. Exceptions ArgumentNullException If the new email is null. UpdatePasswordHash(string) Method to update the password hash of the user. public void UpdatePasswordHash(string newPasswordHash) Parameters newPasswordHash string The new password hash. Exceptions ArgumentNullException If the new password hash is null. UpdateUsername(string) Method to update the username of the user. public void UpdateUsername(string newUsername) Parameters newUsername string The new username. Exceptions ArgumentNullException If the new username is null."
  },
  "api/Lionk.Auth.Identity.UserAuthenticationStateProvider.html": {
    "href": "api/Lionk.Auth.Identity.UserAuthenticationStateProvider.html",
    "title": "Class UserAuthenticationStateProvider | Lionk",
    "keywords": "Class UserAuthenticationStateProvider Namespace Lionk.Auth.Identity Assembly Lionk.Auth.Razor.dll This class is used to provide the authentication state of the user. public class UserAuthenticationStateProvider : AuthenticationStateProvider, IDisposable Inheritance object AuthenticationStateProvider UserAuthenticationStateProvider Implements IDisposable Inherited Members AuthenticationStateProvider.NotifyAuthenticationStateChanged(Task<AuthenticationState>) AuthenticationStateProvider.AuthenticationStateChanged object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UserAuthenticationStateProvider(UserServiceRazor, IUserService) Initializes a new instance of the UserAuthenticationStateProvider class. public UserAuthenticationStateProvider(UserServiceRazor userService, IUserService userServiceImpl) Parameters userService UserServiceRazor The user service to use. userServiceImpl IUserService The local user service implementation. Properties CurrentUser Gets the current user. public User? CurrentUser { get; } Property Value User Methods Dispose() Method to dispose the user authentication state provider. public void Dispose() GetAuthenticationStateAsync() Method to get the authentication state of the user. public override Task<AuthenticationState> GetAuthenticationStateAsync() Returns Task<AuthenticationState> The authentication state of the user. LoginAsync(string, string) Method to get the authentication state of the user. public Task LoginAsync(string username, string passwordHash) Parameters username string The username of the user. passwordHash string The hash of the password of the user. Returns Task The task. LogoutAsync() Method to log out the user. public Task LogoutAsync() Returns Task The task."
  },
  "api/Lionk.Auth.Identity.UserFileHandler.html": {
    "href": "api/Lionk.Auth.Identity.UserFileHandler.html",
    "title": "Class UserFileHandler | Lionk",
    "keywords": "Class UserFileHandler Namespace Lionk.Auth.Identity Assembly Lionk.Auth.dll This class is used to handle the users json files. public class UserFileHandler : IUserRepository Inheritance object UserFileHandler Implements IUserRepository Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties UsersPath Gets the path of the users file. public static string UsersPath { get; } Property Value string Methods DeleteUser(User) Method to delete an user. public void DeleteUser(User user) Parameters user User The user to delete. GetUsers() Method to get all the notifications saved. public HashSet<User> GetUsers() Returns HashSet<User> The list of notifications saved. Exceptions ArgumentNullException If file exists but the result of the deserialization is null. SaveUser(User) Method to save a notification in history. public void SaveUser(User user) Parameters user User The notification to save. UpdateUser(User) Method to update a user. public void UpdateUser(User user) Parameters user User The user to update."
  },
  "api/Lionk.Auth.Identity.UserService.html": {
    "href": "api/Lionk.Auth.Identity.UserService.html",
    "title": "Class UserService | Lionk",
    "keywords": "Class UserService Namespace Lionk.Auth.Identity Assembly Lionk.Auth.dll This class represents a user service. public class UserService : IUserService Inheritance object UserService Implements IUserService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UserService(IUserRepository) Initializes a new instance of the UserService class. public UserService(IUserRepository repository) Parameters repository IUserRepository The user repository. Properties UserRepository Gets or sets the user repository. public IUserRepository UserRepository { get; set; } Property Value IUserRepository Methods Delete(User) Method to delete a user. public bool Delete(User user) Parameters user User Returns bool True if the user was deleted, false otherwise. GetRegisteredUser(string, string) Method to get a registered user. public User? GetRegisteredUser(string username, string passwordHash) Parameters username string The username of the user. passwordHash string The hash of the password of the user. Returns User The registered user. GetUserByEmail(string) Method to get a user by its email. public User? GetUserByEmail(string email) Parameters email string The email of the user. Returns User The user with the email, null if not found. GetUserById(Guid) Method to get a user by its id. public User? GetUserById(Guid id) Parameters id Guid The id of the user. Returns User The user with the id, null if not found. GetUserByUsername(string) Method to get a user by its username. public User? GetUserByUsername(string username) Parameters username string The username of the user. Returns User The user with the username, null if not found. GetUserSalt(string) Method to get the salt of a user. public string GetUserSalt(string username) Parameters username string The username of the user. Returns string The salt of the user. GetUsers() Method to get all the users. public HashSet<User> GetUsers() Returns HashSet<User> The hashSet of all the users. Insert(User) Method to insert a user. public User? Insert(User user) Parameters user User The user to insert. Returns User The inserted user, null the insertion failed. IsEmailExist(string) Method to check if a username exists. public bool IsEmailExist(string email) Parameters email string The user to check. Returns bool True if the username exists, false otherwise. IsFirstUserRegistered() Method to check if the current user being registered is the first user in the system. If true, this indicates that the user should be assigned the Admin role. public bool IsFirstUserRegistered() Returns bool True if the current user is the first to be registered, false otherwise. IsIdExist(Guid) Method to check if an id exists. public bool IsIdExist(Guid id) Parameters id Guid The user to check. Returns bool True if the id exists, false otherwise. IsUsernameExist(string) Method to check if a username exists. public bool IsUsernameExist(string username) Parameters username string The user to check. Returns bool True if the username exists, false otherwise. Update(User) Method to update a user. public User? Update(User user) Parameters user User The user to update. Returns User The updated user, null if the update failed."
  },
  "api/Lionk.Auth.Identity.UserServiceRazor.html": {
    "href": "api/Lionk.Auth.Identity.UserServiceRazor.html",
    "title": "Class UserServiceRazor | Lionk",
    "keywords": "Class UserServiceRazor Namespace Lionk.Auth.Identity Assembly Lionk.Auth.Razor.dll This class represents a user service. public class UserServiceRazor Inheritance object UserServiceRazor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UserServiceRazor(ProtectedLocalStorage) Initializes a new instance of the UserServiceRazor class. public UserServiceRazor(ProtectedLocalStorage protectedLocalStorage) Parameters protectedLocalStorage ProtectedLocalStorage The protected local storage. Methods ClearBrowserUserDataAsync() Method to clear the user data from the browser. public Task ClearBrowserUserDataAsync() Returns Task The task. FetchUserFromBrowserAsync() Method to fetch the user from the browser. public Task<User?> FetchUserFromBrowserAsync() Returns Task<User> The user fetched from the browser. PersistUserToBrowserAsync(User) Persists the user to the browser. public Task PersistUserToBrowserAsync(User user) Parameters user User The user to persist. Returns Task The task."
  },
  "api/Lionk.Auth.Identity.html": {
    "href": "api/Lionk.Auth.Identity.html",
    "title": "Namespace Lionk.Auth.Identity | Lionk",
    "keywords": "Namespace Lionk.Auth.Identity Classes User This class represents a user. UserAuthenticationStateProvider This class is used to provide the authentication state of the user. UserFileHandler This class is used to handle the users json files. UserService This class represents a user service. UserServiceRazor This class represents a user service."
  },
  "api/Lionk.Auth.Utils.PasswordUtils.html": {
    "href": "api/Lionk.Auth.Utils.PasswordUtils.html",
    "title": "Class PasswordUtils | Lionk",
    "keywords": "Class PasswordUtils Namespace Lionk.Auth.Utils Assembly Lionk.Auth.dll This class contains methods to manage users authentication. public static class PasswordUtils Inheritance object PasswordUtils Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GenerateSalt(int) Method to generate a salt with a specific size. public static string GenerateSalt(int size) Parameters size int The size of the salt to generate. Returns string The generated salt. HashPassword(string, string) Method to hash a password with a specific salt. public static string HashPassword(string password, string salt) Parameters password string The password to hash. salt string The salt to use to hash the password. Returns string The hashed password."
  },
  "api/Lionk.Auth.Utils.html": {
    "href": "api/Lionk.Auth.Utils.html",
    "title": "Namespace Lionk.Auth.Utils | Lionk",
    "keywords": "Namespace Lionk.Auth.Utils Classes PasswordUtils This class contains methods to manage users authentication."
  },
  "api/Lionk.Core.Component.BaseComponent.html": {
    "href": "api/Lionk.Core.Component.BaseComponent.html",
    "title": "Class BaseComponent | Lionk",
    "keywords": "Class BaseComponent Namespace Lionk.Core.Component Assembly Lionk.Core.dll Base class implementation for IComponent. public abstract class BaseComponent : ObservableElement, INotifyPropertyChanged, IComponent, IDisposable Inheritance object ObservableElement BaseComponent Implements INotifyPropertyChanged IComponent IDisposable Derived BaseExecutableComponent Inherited Members ObservableElement.PropertyChanged ObservableElement.OnPropertyChanged(string) ObservableElement.SetField<T>(ref T, T, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id Gets the unique identifier of the component. public Guid Id { get; set; } Property Value Guid InstanceName Gets or sets the name of the component. public string InstanceName { get; set; } Property Value string Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public virtual void Dispose()"
  },
  "api/Lionk.Core.Component.BaseCyclicComponent.html": {
    "href": "api/Lionk.Core.Component.BaseCyclicComponent.html",
    "title": "Class BaseCyclicComponent | Lionk",
    "keywords": "Class BaseCyclicComponent Namespace Lionk.Core.Component Assembly Lionk.Core.dll Base class that implements the ICyclicComponent interface. Provides default behavior for cyclic components, managing their life cycle, periodic execution, and cycle count. public abstract class BaseCyclicComponent : BaseExecutableComponent, INotifyPropertyChanged, ICyclicComponent, IExecutableComponent, IComponent, IDisposable Inheritance object ObservableElement BaseComponent BaseExecutableComponent BaseCyclicComponent Implements INotifyPropertyChanged ICyclicComponent IExecutableComponent IComponent IDisposable Derived ComponentWhichGoToError Counter Inherited Members BaseExecutableComponent.CanExecute BaseExecutableComponent.IsInError BaseExecutableComponent.IsRunning BaseExecutableComponent.Abort() BaseExecutableComponent.Dispose() BaseExecutableComponent.Execute() BaseExecutableComponent.Reset() BaseComponent.Id BaseComponent.InstanceName ObservableElement.PropertyChanged ObservableElement.OnPropertyChanged(string) ObservableElement.SetField<T>(ref T, T, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CyclicComputationMethod Gets or sets the method used to compute the next execution time of the component. This can be either relative to the last execution or relative to the start time. public CyclicComputationMethod CyclicComputationMethod { get; set; } Property Value CyclicComputationMethod LastExecution Gets the date and time of the last execution of the component. This property is automatically updated each time the component completes its execution. [JsonIgnore] public DateTime LastExecution { get; } Property Value DateTime NbCycle Gets the number of execution cycles that have been completed by the component. This count is incremented automatically with each execution. [JsonIgnore] public int NbCycle { get; } Property Value int Period Gets or sets the period between each execution of the component. The period must be greater than zero. public TimeSpan Period { get; set; } Property Value TimeSpan Exceptions ArgumentException Thrown if the period is less than or equal to zero. StartedDate Gets the date and time when the component was started. This property is updated automatically when the component is initialized. [JsonIgnore] public DateTime StartedDate { get; } Property Value DateTime Methods OnExecute(CancellationToken) Executes the component, incrementing the cycle count. This method is called during each execution cycle of the component. protected override void OnExecute(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A token that can be used to cancel the execution. OnInitialize() Initializes the component by setting the start date to the current date and time. This method is called automatically during the first execution of the component. protected override void OnInitialize() OnTerminate() Terminates the execution of the component, updating the last execution time. This method is called automatically after the execution logic has completed. protected override void OnTerminate()"
  },
  "api/Lionk.Core.Component.BaseExecutableComponent.html": {
    "href": "api/Lionk.Core.Component.BaseExecutableComponent.html",
    "title": "Class BaseExecutableComponent | Lionk",
    "keywords": "Class BaseExecutableComponent Namespace Lionk.Core.Component Assembly Lionk.Core.dll Base class that implements the IExecutableComponent interface. Provides a template for components that can be executed with a defined life cycle, including initialization, execution, termination phases, and error handling. public abstract class BaseExecutableComponent : BaseComponent, INotifyPropertyChanged, IExecutableComponent, IComponent, IDisposable Inheritance object ObservableElement BaseComponent BaseExecutableComponent Implements INotifyPropertyChanged IExecutableComponent IComponent IDisposable Derived BaseCyclicComponent Inherited Members BaseComponent.Id BaseComponent.InstanceName ObservableElement.PropertyChanged ObservableElement.OnPropertyChanged(string) ObservableElement.SetField<T>(ref T, T, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CanExecute Gets a value indicating whether the component can be executed. This property must be implemented by derived classes to specify the conditions under which the component is ready to execute. public abstract bool CanExecute { get; } Property Value bool IsInError Gets a value indicating whether the component is currently in an error state. This value is set to true if the component encounters an error during execution, or if it is aborted. A component in an error state cannot be executed until it is reset. [JsonIgnore] public bool IsInError { get; } Property Value bool IsRunning Gets a value indicating whether the component is currently running. This value is managed internally and should not be modified directly. [JsonIgnore] public bool IsRunning { get; } Property Value bool Methods Abort() Aborts the component's execution by canceling the ongoing operation. This method sets the IsInError flag to true, preventing further executions until the component is reset. Can be overridden by derived classes to implement custom abort logic. public virtual void Abort() Dispose() Disposes of the component, ensuring that any running execution is aborted before disposal. This method should be called when the component is no longer needed to release resources. public override void Dispose() Execute() Executes the component by initializing it (if not already initialized), then running the execution logic, and finally terminating the execution. public void Execute() Exceptions InvalidOperationException Thrown if the component cannot be executed because it is either in an error state (as indicated by IsInError), is not ready to execute (as determined by CanExecute), or is already running. OnExecute(CancellationToken) The main execution logic of the component. This method is called when the component is executed, and it should be overridden by derived classes to implement the specific behavior of the component. By default, it sets the IsRunning flag to true. protected virtual void OnExecute(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken A token that can be used to cancel the execution. OnInitialize() Called once before the component is executed, if it hasn't been initialized yet. Derived classes can override this method to implement custom initialization logic. By default, this method sets the _isInitialized flag to true. protected virtual void OnInitialize() OnTerminate() Called after the execution logic has completed, regardless of whether it succeeded or failed. Derived classes can override this method to implement custom termination logic. By default, this method sets the IsRunning flag to false. protected virtual void OnTerminate() Reset() Resets the component, clearing the error state and allowing it to be executed again. This method cannot be called while the component is running. public void Reset() Exceptions InvalidOperationException Thrown if the component is running when an attempt is made to reset it."
  },
  "api/Lionk.Core.Component.ComponentFactory.html": {
    "href": "api/Lionk.Core.Component.ComponentFactory.html",
    "title": "Class ComponentFactory | Lionk",
    "keywords": "Class ComponentFactory Namespace Lionk.Core.Component Assembly Lionk.Core.dll Factory for components. public class ComponentFactory : Factory Inheritance object Factory ComponentFactory Inherited Members Factory.Type Factory.CreateInstance() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComponentFactory(Type) Factory for components. public ComponentFactory(Type type) Parameters type Type ComponentFactory(Type, IComponentService) Initializes a new instance of the ComponentFactory class. public ComponentFactory(Type type, IComponentService service) Parameters type Type The type to instantiate. service IComponentService The service used to register instance. Methods OnCreateInstance(object) Called when a new instance is created. protected override void OnCreateInstance(object instance) Parameters instance object the created instance."
  },
  "api/Lionk.Core.Component.ComponentRegister.html": {
    "href": "api/Lionk.Core.Component.ComponentRegister.html",
    "title": "Class ComponentRegister | Lionk",
    "keywords": "Class ComponentRegister Namespace Lionk.Core.Component Assembly Lionk.Core.dll Class that stores elements implementing IComponent Elements can be extended using the ITypesProvider to provide new types. public class ComponentRegister : IDisposable Inheritance object ComponentRegister Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the ComponentRegister class. Constructors ComponentRegister(IComponentService) Class that stores elements implementing IComponent Elements can be extended using the ITypesProvider to provide new types. public ComponentRegister(IComponentService service) Parameters service IComponentService The component service. Remarks Initializes a new instance of the ComponentRegister class. ComponentRegister(ITypesProvider, IComponentService) Initializes a new instance of the ComponentRegister class. public ComponentRegister(ITypesProvider provider, IComponentService service) Parameters provider ITypesProvider A ITypesProvider to poll for new types. service IComponentService The component service. ComponentRegister(IEnumerable<ITypesProvider>, IComponentService) Initializes a new instance of the ComponentRegister class. public ComponentRegister(IEnumerable<ITypesProvider> providers, IComponentService service) Parameters providers IEnumerable<ITypesProvider> A list of component providers. service IComponentService The component service. Properties TypesRegister Gets a dictionary containing all registered Type and theirs factory. public ReadOnlyDictionary<ComponentTypeDescription, Factory> TypesRegister { get; } Property Value ReadOnlyDictionary<ComponentTypeDescription, Factory> Methods AddProvider(ITypesProvider) Used to add a provider. public void AddProvider(ITypesProvider provider) Parameters provider ITypesProvider Provider to add. DeleteProvider(ITypesProvider) Used to delete a provider. public void DeleteProvider(ITypesProvider provider) Parameters provider ITypesProvider The provider to delete. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Events NewComponentAvailable Event raised when a new type is available. public event EventHandler<EventArgs>? NewComponentAvailable Event Type EventHandler<EventArgs>"
  },
  "api/Lionk.Core.Component.ComponentService.html": {
    "href": "api/Lionk.Core.Component.ComponentService.html",
    "title": "Class ComponentService | Lionk",
    "keywords": "Class ComponentService Namespace Lionk.Core.Component Assembly Lionk.Core.dll Service that manages components. public class ComponentService : IComponentService, IDisposable Inheritance object ComponentService Implements IComponentService IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComponentService(ITypesProvider) Initializes a new instance of the ComponentService class. public ComponentService(ITypesProvider provider) Parameters provider ITypesProvider The type provider. Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetInstanceById(Guid) Get an instance by its unique identifier. public IComponent? GetInstanceById(Guid id) Parameters id Guid The id. Returns IComponent A component with id, or null if no component exist. GetInstanceByName(string) Get an instance by InstanceName. public IComponent? GetInstanceByName(string name) Parameters name string The instance name. Returns IComponent The IComponent define by its name, null if not registered. GetInstances() Get all instances registered. public IEnumerable<IComponent> GetInstances() Returns IEnumerable<IComponent> An IEnumerable<T> containing all registered instance. GetInstancesOfType<T>() Get all instances of components of type T. public IEnumerable<T> GetInstancesOfType<T>() Returns IEnumerable<T> An IEnumerable<T> containing all registered instance of T. Type Parameters T The type of the components. GetRegisteredTypeDictionary() Get all registered types from ITypesProvider. public IReadOnlyDictionary<ComponentTypeDescription, Factory> GetRegisteredTypeDictionary() Returns IReadOnlyDictionary<ComponentTypeDescription, Factory> A IDictionary<TKey, TValue> which contains information about registered components.\"/>. RegisterComponentInstance(IComponent) Register a component. public void RegisterComponentInstance(IComponent component) Parameters component IComponent the component to register. UnregisterComponentInstance(IComponent) Unregister a component. public void UnregisterComponentInstance(IComponent component) Parameters component IComponent Unregister the instance. Events NewComponentAvailable Event raised when a new type is available. public event EventHandler<EventArgs>? NewComponentAvailable Event Type EventHandler<EventArgs> NewInstanceRegistered Event raised when a new instance is registered. public event EventHandler<EventArgs>? NewInstanceRegistered Event Type EventHandler<EventArgs>"
  },
  "api/Lionk.Core.Component.ComponentTypeDescription.html": {
    "href": "api/Lionk.Core.Component.ComponentTypeDescription.html",
    "title": "Class ComponentTypeDescription | Lionk",
    "keywords": "Class ComponentTypeDescription Namespace Lionk.Core.Component Assembly Lionk.Core.dll Define a component type description. public class ComponentTypeDescription Inheritance object ComponentTypeDescription Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComponentTypeDescription(Type) Initializes a new instance of the ComponentTypeDescription class. public ComponentTypeDescription(Type type) Parameters type Type The type of the component. Properties Description Gets the description of the component. public string Description { get; } Property Value string Name Gets the name of the component. public string Name { get; } Property Value string Type Gets the type of the component. public Type Type { get; } Property Value Type"
  },
  "api/Lionk.Core.Component.Cyclic.CycleState.html": {
    "href": "api/Lionk.Core.Component.Cyclic.CycleState.html",
    "title": "Enum CycleState | Lionk",
    "keywords": "Enum CycleState Namespace Lionk.Core.Component.Cyclic Assembly Lionk.Core.dll This enum represents the state of a cycle. public enum CycleState Fields Paused = 1 The cycle is paused. Running = 2 The cycle is running. Stopped = 0 The cycle is stopped. Stopping = 3 The cycle is stopping."
  },
  "api/Lionk.Core.Component.Cyclic.CyclicComputationMethod.html": {
    "href": "api/Lionk.Core.Component.Cyclic.CyclicComputationMethod.html",
    "title": "Enum CyclicComputationMethod | Lionk",
    "keywords": "Enum CyclicComputationMethod Namespace Lionk.Core.Component.Cyclic Assembly Lionk.Core.dll This enumeration defines the cyclic computation method. public enum CyclicComputationMethod Extension Methods CyclicComputationMethodExtension.GetNextExecution(CyclicComputationMethod, ICyclicComponent) Fields RelativeToLastExecution = 0 The computation is relative to the last execution. RelativeToStartTime = 1 The computation is relative to the start time + the number of cycles * period."
  },
  "api/Lionk.Core.Component.Cyclic.CyclicComputationMethodExtension.html": {
    "href": "api/Lionk.Core.Component.Cyclic.CyclicComputationMethodExtension.html",
    "title": "Class CyclicComputationMethodExtension | Lionk",
    "keywords": "Class CyclicComputationMethodExtension Namespace Lionk.Core.Component.Cyclic Assembly Lionk.Core.dll This class defines the extension methods for the CyclicComputationMethod enumeration. public static class CyclicComputationMethodExtension Inheritance object CyclicComputationMethodExtension Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetNextExecution(CyclicComputationMethod, ICyclicComponent) This method returns the next execution time of a cyclic component. public static DateTime GetNextExecution(this CyclicComputationMethod method, ICyclicComponent component) Parameters method CyclicComputationMethod The cyclic computation method. component ICyclicComponent The cyclic component. Returns DateTime The next execution time."
  },
  "api/Lionk.Core.Component.Cyclic.CyclicExecutorService.html": {
    "href": "api/Lionk.Core.Component.Cyclic.CyclicExecutorService.html",
    "title": "Class CyclicExecutorService | Lionk",
    "keywords": "Class CyclicExecutorService Namespace Lionk.Core.Component.Cyclic Assembly Lionk.Core.dll Service responsible for executing cyclic components and managing their execution cycle. public class CyclicExecutorService : ObservableElement, INotifyPropertyChanged, ICyclicExecutorService Inheritance object ObservableElement CyclicExecutorService Implements INotifyPropertyChanged ICyclicExecutorService Inherited Members ObservableElement.PropertyChanged ObservableElement.OnPropertyChanged(string) ObservableElement.SetField<T>(ref T, T, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CyclicExecutorService(IComponentService) Initializes a new instance of the CyclicExecutorService class. public CyclicExecutorService(IComponentService componentService) Parameters componentService IComponentService The service that provides access to components. Properties Components Gets the collection of cyclic components managed by the service. public IEnumerable<ICyclicComponent> Components { get; } Property Value IEnumerable<ICyclicComponent> LastExecutionTime Gets or sets the last execution time of the service. public TimeSpan LastExecutionTime { get; set; } Property Value TimeSpan MaxCycleTime Gets or sets the maximum cycle time. This is the maximum time between the start of two consecutive cycles. public TimeSpan MaxCycleTime { get; set; } Property Value TimeSpan MeanCycleTime Gets or sets the mean cycle time. This is the average time between the start of two consecutive cycles. public TimeSpan MeanCycleTime { get; set; } Property Value TimeSpan State Gets the current state of the service. public CycleState State { get; set; } Property Value CycleState WatchDogTimeout Gets or sets the watchdog timeout. If a component's execution exceeds this duration, the service will take appropriate action. [JsonProperty] public TimeSpan WatchDogTimeout { get; set; } Property Value TimeSpan Methods Abort() Abort method. public void Abort() Pause() Pauses the cyclic execution service, halting the execution of components without stopping the service. public void Pause() Resume() Resumes the cyclic execution service from a paused state. public void Resume() Start() Starts the cyclic execution service. public void Start() Stop() Stops the cyclic execution service, including all ongoing component executions. public void Stop()"
  },
  "api/Lionk.Core.Component.Cyclic.ICyclicExecutorService.html": {
    "href": "api/Lionk.Core.Component.Cyclic.ICyclicExecutorService.html",
    "title": "Interface ICyclicExecutorService | Lionk",
    "keywords": "Interface ICyclicExecutorService Namespace Lionk.Core.Component.Cyclic Assembly Lionk.Core.dll Interface for a service that manages the execution of cyclic components. public interface ICyclicExecutorService Properties Components Gets the collection of cyclic components managed by the service. IEnumerable<ICyclicComponent> Components { get; } Property Value IEnumerable<ICyclicComponent> LastExecutionTime Gets or sets the last execution time of the service. TimeSpan LastExecutionTime { get; set; } Property Value TimeSpan MaxCycleTime Gets or sets the maximum cycle time. This is the maximum time between the start of two consecutive cycles. TimeSpan MaxCycleTime { get; set; } Property Value TimeSpan MeanCycleTime Gets or sets the mean cycle time. This is the average time between the start of two consecutive cycles. TimeSpan MeanCycleTime { get; set; } Property Value TimeSpan State Gets the current state of the service. CycleState State { get; } Property Value CycleState WatchDogTimeout Gets or sets the watchdog timeout. If a component's execution exceeds this duration, the service will take appropriate action. TimeSpan WatchDogTimeout { get; set; } Property Value TimeSpan Methods Pause() Pauses the cyclic execution service, halting the execution of components without stopping the service. void Pause() Resume() Resumes the cyclic execution service from a paused state. void Resume() Start() Starts the cyclic execution service. void Start() Stop() Stops the cyclic execution service, including all ongoing component executions. void Stop()"
  },
  "api/Lionk.Core.Component.Cyclic.html": {
    "href": "api/Lionk.Core.Component.Cyclic.html",
    "title": "Namespace Lionk.Core.Component.Cyclic | Lionk",
    "keywords": "Namespace Lionk.Core.Component.Cyclic Classes CyclicComputationMethodExtension This class defines the extension methods for the CyclicComputationMethod enumeration. CyclicExecutorService Service responsible for executing cyclic components and managing their execution cycle. Interfaces ICyclicExecutorService Interface for a service that manages the execution of cyclic components. Enums CycleState This enum represents the state of a cycle. CyclicComputationMethod This enumeration defines the cyclic computation method."
  },
  "api/Lionk.Core.Component.IComponent.html": {
    "href": "api/Lionk.Core.Component.IComponent.html",
    "title": "Interface IComponent | Lionk",
    "keywords": "Interface IComponent Namespace Lionk.Core.Component Assembly Lionk.Core.dll Interface that define a component. public interface IComponent : IDisposable Inherited Members IDisposable.Dispose() Properties Id Gets the unique identifier of the component. Guid Id { get; } Property Value Guid InstanceName Gets or sets the name of the component. string InstanceName { get; set; } Property Value string"
  },
  "api/Lionk.Core.Component.IComponentService.html": {
    "href": "api/Lionk.Core.Component.IComponentService.html",
    "title": "Interface IComponentService | Lionk",
    "keywords": "Interface IComponentService Namespace Lionk.Core.Component Assembly Lionk.Core.dll Interface for component service. public interface IComponentService : IDisposable Inherited Members IDisposable.Dispose() Methods GetInstanceById(Guid) Get an instance by its unique identifier. IComponent? GetInstanceById(Guid id) Parameters id Guid The id. Returns IComponent A component with id, or null if no component exist. GetInstanceByName(string) Get an instance by InstanceName. IComponent? GetInstanceByName(string name) Parameters name string The instance name. Returns IComponent The IComponent define by its name, null if not registered. GetInstances() Get all instances registered. IEnumerable<IComponent> GetInstances() Returns IEnumerable<IComponent> An IEnumerable<T> containing all registered instance. GetInstancesOfType<T>() Get all instances of components of type T. IEnumerable<T> GetInstancesOfType<T>() Returns IEnumerable<T> An IEnumerable<T> containing all registered instance of T. Type Parameters T The type of the components. GetRegisteredTypeDictionary() Get all registered types from ITypesProvider. IReadOnlyDictionary<ComponentTypeDescription, Factory> GetRegisteredTypeDictionary() Returns IReadOnlyDictionary<ComponentTypeDescription, Factory> A IDictionary<TKey, TValue> which contains information about registered components.\"/>. RegisterComponentInstance(IComponent) Register a component. void RegisterComponentInstance(IComponent component) Parameters component IComponent the component to register. UnregisterComponentInstance(IComponent) Unregister a component. void UnregisterComponentInstance(IComponent component) Parameters component IComponent Unregister the instance. Events NewComponentAvailable Event raised when a new type is available. event EventHandler<EventArgs> NewComponentAvailable Event Type EventHandler<EventArgs> NewInstanceRegistered Event raised when a new instance is registered. event EventHandler<EventArgs> NewInstanceRegistered Event Type EventHandler<EventArgs>"
  },
  "api/Lionk.Core.Component.ICyclicComponent.html": {
    "href": "api/Lionk.Core.Component.ICyclicComponent.html",
    "title": "Interface ICyclicComponent | Lionk",
    "keywords": "Interface ICyclicComponent Namespace Lionk.Core.Component Assembly Lionk.Core.dll This interface defines a cyclic component. public interface ICyclicComponent : IExecutableComponent, IComponent, IDisposable Inherited Members IExecutableComponent.CanExecute IExecutableComponent.IsInError IExecutableComponent.IsRunning IExecutableComponent.Abort() IExecutableComponent.Execute() IExecutableComponent.Reset() IComponent.Id IComponent.InstanceName IDisposable.Dispose() Properties CyclicComputationMethod Gets or sets the cyclic computation method. CyclicComputationMethod CyclicComputationMethod { get; set; } Property Value CyclicComputationMethod LastExecution Gets the last execution time of the component. DateTime LastExecution { get; } Property Value DateTime NbCycle Gets the number of cycles executed. int NbCycle { get; } Property Value int NextExecution Gets the next execution time of the component depending on the CyclicComputationMethod. DateTime NextExecution { get; } Property Value DateTime Period Gets or sets the period of the component. TimeSpan Period { get; set; } Property Value TimeSpan StartedDate Gets the starting date of the component. DateTime StartedDate { get; } Property Value DateTime"
  },
  "api/Lionk.Core.Component.IExecutableComponent.html": {
    "href": "api/Lionk.Core.Component.IExecutableComponent.html",
    "title": "Interface IExecutableComponent | Lionk",
    "keywords": "Interface IExecutableComponent Namespace Lionk.Core.Component Assembly Lionk.Core.dll This interface defines a cyclic component. public interface IExecutableComponent : IComponent, IDisposable Inherited Members IComponent.Id IComponent.InstanceName IDisposable.Dispose() Properties CanExecute Gets a value indicating whether the component can be executed. bool CanExecute { get; } Property Value bool IsInError Gets a value indicating whether the component is in error. bool IsInError { get; } Property Value bool IsRunning Gets a value indicating whether the component is running. bool IsRunning { get; } Property Value bool Methods Abort() Abort the current execution. void Abort() Execute() Executes the component. void Execute() Reset() Used to reset the component. void Reset()"
  },
  "api/Lionk.Core.Component.IMeasurableComponent-1.html": {
    "href": "api/Lionk.Core.Component.IMeasurableComponent-1.html",
    "title": "Interface IMeasurableComponent<T> | Lionk",
    "keywords": "Interface IMeasurableComponent<T> Namespace Lionk.Core.Component Assembly Lionk.Core.dll This interface defines a measurable component. public interface IMeasurableComponent<T> : IComponent, IDisposable Type Parameters T The type of the value. Inherited Members IComponent.Id IComponent.InstanceName IDisposable.Dispose() Properties Measures Gets the measures of the component. List<Measure<T>> Measures { get; } Property Value List<Measure<T>> Methods Measure() This method processes the measures. void Measure() Events NewValueAvailable Raised when a new value is available. event EventHandler<MeasureEventArgs<T>>? NewValueAvailable Event Type EventHandler<MeasureEventArgs<T>>"
  },
  "api/Lionk.Core.Component.html": {
    "href": "api/Lionk.Core.Component.html",
    "title": "Namespace Lionk.Core.Component | Lionk",
    "keywords": "Namespace Lionk.Core.Component Classes BaseComponent Base class implementation for IComponent. BaseCyclicComponent Base class that implements the ICyclicComponent interface. Provides default behavior for cyclic components, managing their life cycle, periodic execution, and cycle count. BaseExecutableComponent Base class that implements the IExecutableComponent interface. Provides a template for components that can be executed with a defined life cycle, including initialization, execution, termination phases, and error handling. ComponentFactory Factory for components. ComponentRegister Class that stores elements implementing IComponent Elements can be extended using the ITypesProvider to provide new types. ComponentService Service that manages components. ComponentTypeDescription Define a component type description. Interfaces IComponent Interface that define a component. IComponentService Interface for component service. ICyclicComponent This interface defines a cyclic component. IExecutableComponent This interface defines a cyclic component. IMeasurableComponent<T> This interface defines a measurable component."
  },
  "api/Lionk.Core.DataModel.Measure-1.html": {
    "href": "api/Lionk.Core.DataModel.Measure-1.html",
    "title": "Class Measure<T> | Lionk",
    "keywords": "Class Measure<T> Namespace Lionk.Core.DataModel Assembly Lionk.Core.dll Represents a measure. public record Measure<T> : IEquatable<Measure<T>> Type Parameters T The type of the value measured. Inheritance object Measure<T> Implements IEquatable<Measure<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Measure(string, DateTime, string, T) Represents a measure. public Measure(string MeasureName, DateTime Time, string Unit, T Value) Parameters MeasureName string The measure name. Time DateTime The time. Unit string The unit of the measure. Value T The value of the measure. Properties MeasureName The measure name. public string MeasureName { get; init; } Property Value string Time The time. public DateTime Time { get; init; } Property Value DateTime Unit The unit of the measure. public string Unit { get; init; } Property Value string Value The value of the measure. public T Value { get; init; } Property Value T"
  },
  "api/Lionk.Core.DataModel.MeasureEventArgs-1.html": {
    "href": "api/Lionk.Core.DataModel.MeasureEventArgs-1.html",
    "title": "Class MeasureEventArgs<T> | Lionk",
    "keywords": "Class MeasureEventArgs<T> Namespace Lionk.Core.DataModel Assembly Lionk.Core.dll Provides data for the MeasureAvailable event. public class MeasureEventArgs<T> : EventArgs Type Parameters T The type of the value. Inheritance object EventArgs MeasureEventArgs<T> Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the MeasureEventArgs<T> class. Constructors MeasureEventArgs(IEnumerable<Measure<T>>) Provides data for the MeasureAvailable event. public MeasureEventArgs(IEnumerable<Measure<T>> measures) Parameters measures IEnumerable<Measure<T>> Remarks Initializes a new instance of the MeasureEventArgs<T> class. Properties Measures Gets the new types that is available. public IEnumerable<Measure<T>> Measures { get; } Property Value IEnumerable<Measure<T>>"
  },
  "api/Lionk.Core.DataModel.html": {
    "href": "api/Lionk.Core.DataModel.html",
    "title": "Namespace Lionk.Core.DataModel | Lionk",
    "keywords": "Namespace Lionk.Core.DataModel Classes MeasureEventArgs<T> Provides data for the MeasureAvailable event. Measure<T> Represents a measure."
  },
  "api/Lionk.Core.Dialog.ComponentDialog.html": {
    "href": "api/Lionk.Core.Dialog.ComponentDialog.html",
    "title": "Class ComponentDialog | Lionk",
    "keywords": "Class ComponentDialog Namespace Lionk.Core.Dialog Assembly Lionk.Core.Razor.dll public class ComponentDialog : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase ComponentDialog Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Component The component to display. [Parameter] public object? Component { get; set; } Property Value object CurrentIndex The index of the currently selected view. [Parameter] public int CurrentIndex { get; set; } Property Value int ViewDescriptions The list of view descriptions. [Parameter] public List<ComponentViewDescription>? ViewDescriptions { get; set; } Property Value List<ComponentViewDescription> Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. protected override void OnInitialized()"
  },
  "api/Lionk.Core.Dialog.SimpleQuestionDialog.html": {
    "href": "api/Lionk.Core.Dialog.SimpleQuestionDialog.html",
    "title": "Class SimpleQuestionDialog | Lionk",
    "keywords": "Class SimpleQuestionDialog Namespace Lionk.Core.Dialog Assembly Lionk.Core.Razor.dll public class SimpleQuestionDialog : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase SimpleQuestionDialog Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ButtonText The button text. [Parameter] public string? ButtonText { get; set; } Property Value string Color The color used for the button. [Parameter] public Color Color { get; set; } Property Value Color ContentText The content text. [Parameter] public string? ContentText { get; set; } Property Value string Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.Dialog.html": {
    "href": "api/Lionk.Core.Dialog.html",
    "title": "Namespace Lionk.Core.Dialog | Lionk",
    "keywords": "Namespace Lionk.Core.Dialog Classes ComponentDialog SimpleQuestionDialog"
  },
  "api/Lionk.Core.Model.Component.ComponentContainer.html": {
    "href": "api/Lionk.Core.Model.Component.ComponentContainer.html",
    "title": "Class ComponentContainer | Lionk",
    "keywords": "Class ComponentContainer Namespace Lionk.Core.Model.Component Assembly Lionk.Core.dll Container for component instance. public class ComponentContainer : ObservableElement, INotifyPropertyChanged Inheritance object ObservableElement ComponentContainer Implements INotifyPropertyChanged Inherited Members ObservableElement.PropertyChanged ObservableElement.OnPropertyChanged(string) ObservableElement.SetField<T>(ref T, T, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComponentContainer(IComponentService, Guid) Initializes a new instance of the ComponentContainer class. public ComponentContainer(IComponentService componentService, Guid componentId) Parameters componentService IComponentService component service. componentId Guid component instance unique ID. Properties Component Gets the component instance. public IComponent? Component { get; } Property Value IComponent ComponentId Gets or sets the component instance unique ID. public Guid ComponentId { get; set; } Property Value Guid Events NewComponentAvailable Occurs when a new component is available. public event EventHandler? NewComponentAvailable Event Type EventHandler"
  },
  "api/Lionk.Core.Model.Component.html": {
    "href": "api/Lionk.Core.Model.Component.html",
    "title": "Namespace Lionk.Core.Model.Component | Lionk",
    "keywords": "Namespace Lionk.Core.Model.Component Classes ComponentContainer Container for component instance."
  },
  "api/Lionk.Core.NamedElement.html": {
    "href": "api/Lionk.Core.NamedElement.html",
    "title": "Class NamedElement | Lionk",
    "keywords": "Class NamedElement Namespace Lionk.Core Assembly Lionk.Core.dll Attribute to define the name of a viewable component. [AttributeUsage(AttributeTargets.Class|AttributeTargets.Interface, Inherited = false)] public class NamedElement : Attribute Inheritance object Attribute NamedElement Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the NamedElement class. Constructors NamedElement(string, string) Attribute to define the name of a viewable component. public NamedElement(string name, string description) Parameters name string The name. description string The description. Remarks Initializes a new instance of the NamedElement class. Properties Description Gets the description of the item. public string Description { get; } Property Value string Name Gets the name of the item. public string Name { get; } Property Value string"
  },
  "api/Lionk.Core.Observable.ObservableElement.html": {
    "href": "api/Lionk.Core.Observable.ObservableElement.html",
    "title": "Class ObservableElement | Lionk",
    "keywords": "Class ObservableElement Namespace Lionk.Core.Observable Assembly Lionk.Core.dll An abstract class that implement INotifyPropertyChanged. public abstract class ObservableElement : INotifyPropertyChanged Inheritance object ObservableElement Implements INotifyPropertyChanged Derived BaseComponent CyclicExecutorService ComponentContainer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods OnPropertyChanged(string) Raises the PropertyChanged event. protected void OnPropertyChanged(string propertyName) Parameters propertyName string The name of the property that changed. SetField<T>(ref T, T, string) Sets the field and raises the PropertyChanged event if the value has changed. protected bool SetField<T>(ref T field, T value, string propertyName = \"\") Parameters field T A referencing to the field backing the property. value T The new value for the property. propertyName string The name of the property that changed. This is automatically supplied by the CallerMemberAttribute. Returns bool True if the value was changed and the event was raised. False otherwise. Type Parameters T The type of the property. Events PropertyChanged Occurs when a property value changes. public event PropertyChangedEventHandler? PropertyChanged Event Type PropertyChangedEventHandler"
  },
  "api/Lionk.Core.Observable.html": {
    "href": "api/Lionk.Core.Observable.html",
    "title": "Namespace Lionk.Core.Observable | Lionk",
    "keywords": "Namespace Lionk.Core.Observable Classes ObservableElement An abstract class that implement INotifyPropertyChanged."
  },
  "api/Lionk.Core.Razor.ComponentList.html": {
    "href": "api/Lionk.Core.Razor.ComponentList.html",
    "title": "Class ComponentList | Lionk",
    "keywords": "Class ComponentList Namespace Lionk.Core.Razor Assembly Lionk.Core.Razor.dll public class ComponentList : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase ComponentList Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties OnComponentSelected Method to call when a component is selected. [Parameter] public EventCallback<KeyValuePair<ComponentTypeDescription, Factory>> OnComponentSelected { get; set; } Property Value EventCallback<KeyValuePair<ComponentTypeDescription, Factory>> TypesRegistry The types registry used to display the components. [Parameter] public IReadOnlyDictionary<ComponentTypeDescription, Factory> TypesRegistry { get; set; } Property Value IReadOnlyDictionary<ComponentTypeDescription, Factory> Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder OnParametersSet() Method invoked when the component has received parameters from its parent in the render tree, and the incoming values have been assigned to properties. protected override void OnParametersSet()"
  },
  "api/Lionk.Core.Razor.IComponentInstanceList.html": {
    "href": "api/Lionk.Core.Razor.IComponentInstanceList.html",
    "title": "Class IComponentInstanceList | Lionk",
    "keywords": "Class IComponentInstanceList Namespace Lionk.Core.Razor Assembly Lionk.Core.Razor.dll public class IComponentInstanceList : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase IComponentInstanceList Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Components The components to display. [Parameter] public IEnumerable<IComponent> Components { get; set; } Property Value IEnumerable<IComponent> OnComponentSelected The method to call when a component is selected. [Parameter] public EventCallback<IComponent> OnComponentSelected { get; set; } Property Value EventCallback<IComponent> Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder OnParametersSet() Method invoked when the component has received parameters from its parent in the render tree, and the incoming values have been assigned to properties. protected override void OnParametersSet()"
  },
  "api/Lionk.Core.Razor.ListSearcher-1.html": {
    "href": "api/Lionk.Core.Razor.ListSearcher-1.html",
    "title": "Class ListSearcher<T> | Lionk",
    "keywords": "Class ListSearcher<T> Namespace Lionk.Core.Razor Assembly Lionk.Core.Razor.dll public class ListSearcher<T> : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Type Parameters T Inheritance object ComponentBase ListSearcher<T> Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Items Gets or sets the items to be searched. [Parameter] public List<T> Items { get; set; } Property Value List<T> ItemsChanged The event that is triggered when the items are changed. [Parameter] public EventCallback<List<T>> ItemsChanged { get; set; } Property Value EventCallback<List<T>> Properties Gets or sets the properties to be searched inside the items. [Parameter] public List<string> Properties { get; set; } Property Value List<string> PropertiesFriendlyNames Gets or sets the friendly names of the properties to be displayed on the checkboxes. [Parameter] public List<string> PropertiesFriendlyNames { get; set; } Property Value List<string> Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. protected override void OnInitialized()"
  },
  "api/Lionk.Core.Razor.Service.CyclicExecutorHostedService.html": {
    "href": "api/Lionk.Core.Razor.Service.CyclicExecutorHostedService.html",
    "title": "Class CyclicExecutorHostedService | Lionk",
    "keywords": "Class CyclicExecutorHostedService Namespace Lionk.Core.Razor.Service Assembly Lionk.Core.Razor.dll This class is used to nest a CyclicExecutorService into a hosted service. public class CyclicExecutorHostedService : IHostedService Inheritance object CyclicExecutorHostedService Implements IHostedService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the CyclicExecutorHostedService class. Constructors CyclicExecutorHostedService(ICyclicExecutorService) This class is used to nest a CyclicExecutorService into a hosted service. public CyclicExecutorHostedService(ICyclicExecutorService cyclicExecutorService) Parameters cyclicExecutorService ICyclicExecutorService The cyclicExecutorService. Remarks Initializes a new instance of the CyclicExecutorHostedService class. Methods StartAsync(CancellationToken) Triggered when the application host is ready to start the service. public Task StartAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Indicates that the start process has been aborted. Returns Task A Task that represents the asynchronous Start operation. StopAsync(CancellationToken) Triggered when the application host is performing a graceful shutdown. public Task StopAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Indicates that the shutdown process should no longer be graceful. Returns Task A Task that represents the asynchronous Stop operation."
  },
  "api/Lionk.Core.Razor.Service.html": {
    "href": "api/Lionk.Core.Razor.Service.html",
    "title": "Namespace Lionk.Core.Razor.Service | Lionk",
    "keywords": "Namespace Lionk.Core.Razor.Service Classes CyclicExecutorHostedService This class is used to nest a CyclicExecutorService into a hosted service."
  },
  "api/Lionk.Core.Razor.Views.CyclicComponent.CyclicComponentCard.html": {
    "href": "api/Lionk.Core.Razor.Views.CyclicComponent.CyclicComponentCard.html",
    "title": "Class CyclicComponentCard | Lionk",
    "keywords": "Class CyclicComponentCard Namespace Lionk.Core.Razor.Views.CyclicComponent Assembly Lionk.Core.Razor.dll public class CyclicComponentCard : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase CyclicComponentCard Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Component The cyclic component to display. [Parameter] public ICyclicComponent? Component { get; set; } Property Value ICyclicComponent Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.Razor.Views.CyclicComponent.html": {
    "href": "api/Lionk.Core.Razor.Views.CyclicComponent.html",
    "title": "Namespace Lionk.Core.Razor.Views.CyclicComponent | Lionk",
    "keywords": "Namespace Lionk.Core.Razor.Views.CyclicComponent Classes CyclicComponentCard"
  },
  "api/Lionk.Core.Razor.Views.CyclicExecutor.CycleTimeGraph.html": {
    "href": "api/Lionk.Core.Razor.Views.CyclicExecutor.CycleTimeGraph.html",
    "title": "Class CycleTimeGraph | Lionk",
    "keywords": "Class CycleTimeGraph Namespace Lionk.Core.Razor.Views.CyclicExecutor Assembly Lionk.Core.Razor.dll public class CycleTimeGraph : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase CycleTimeGraph Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder Dispose() public void Dispose() OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. protected override void OnInitialized() OnParametersSet() Method invoked when the component has received parameters from its parent in the render tree, and the incoming values have been assigned to properties. protected override void OnParametersSet()"
  },
  "api/Lionk.Core.Razor.Views.CyclicExecutor.CyclicExecutorStatusCard.html": {
    "href": "api/Lionk.Core.Razor.Views.CyclicExecutor.CyclicExecutorStatusCard.html",
    "title": "Class CyclicExecutorStatusCard | Lionk",
    "keywords": "Class CyclicExecutorStatusCard Namespace Lionk.Core.Razor.Views.CyclicExecutor Assembly Lionk.Core.Razor.dll public class CyclicExecutorStatusCard : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase CyclicExecutorStatusCard Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.Razor.Views.CyclicExecutor.CyclicExecutorView.html": {
    "href": "api/Lionk.Core.Razor.Views.CyclicExecutor.CyclicExecutorView.html",
    "title": "Class CyclicExecutorView | Lionk",
    "keywords": "Class CyclicExecutorView Namespace Lionk.Core.Razor.Views.CyclicExecutor Assembly Lionk.Core.Razor.dll public class CyclicExecutorView : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase CyclicExecutorView Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder Dispose() public void Dispose() OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. protected override void OnInitialized()"
  },
  "api/Lionk.Core.Razor.Views.CyclicExecutor.ToggleCyclicExecutor.html": {
    "href": "api/Lionk.Core.Razor.Views.CyclicExecutor.ToggleCyclicExecutor.html",
    "title": "Class ToggleCyclicExecutor | Lionk",
    "keywords": "Class ToggleCyclicExecutor Namespace Lionk.Core.Razor.Views.CyclicExecutor Assembly Lionk.Core.Razor.dll public class ToggleCyclicExecutor : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase ToggleCyclicExecutor Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.Razor.Views.CyclicExecutor.html": {
    "href": "api/Lionk.Core.Razor.Views.CyclicExecutor.html",
    "title": "Namespace Lionk.Core.Razor.Views.CyclicExecutor | Lionk",
    "keywords": "Namespace Lionk.Core.Razor.Views.CyclicExecutor Classes CycleTimeGraph CyclicExecutorStatusCard CyclicExecutorView ToggleCyclicExecutor"
  },
  "api/Lionk.Core.Razor._imports.html": {
    "href": "api/Lionk.Core.Razor._imports.html",
    "title": "Class _imports | Lionk",
    "keywords": "Class _imports Namespace Lionk.Core.Razor Assembly Lionk.Core.Razor.dll public class _imports : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase _imports Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.Razor.html": {
    "href": "api/Lionk.Core.Razor.html",
    "title": "Namespace Lionk.Core.Razor | Lionk",
    "keywords": "Namespace Lionk.Core.Razor Classes ComponentList IComponentInstanceList ListSearcher<T> _imports"
  },
  "api/Lionk.Core.TypeRegister.Factory.html": {
    "href": "api/Lionk.Core.TypeRegister.Factory.html",
    "title": "Class Factory | Lionk",
    "keywords": "Class Factory Namespace Lionk.Core.TypeRegister Assembly Lionk.Core.dll Class that create instances of a type. public abstract class Factory Inheritance object Factory Derived ComponentFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Factory(Type) Initializes a new instance of the Factory class. protected Factory(Type type) Parameters type Type The type created by the factory. Properties Type Gets the type used by the factory. public Type Type { get; } Property Value Type Methods CreateInstance() Create a new instance of the type. public object? CreateInstance() Returns object A new instance of the type used by the factory. If the creation is unsuccessful, return null. OnCreateInstance(object) Called when a new instance is created. protected abstract void OnCreateInstance(object instance) Parameters instance object the created instance."
  },
  "api/Lionk.Core.TypeRegister.ITypesProvider.html": {
    "href": "api/Lionk.Core.TypeRegister.ITypesProvider.html",
    "title": "Interface ITypesProvider | Lionk",
    "keywords": "Interface ITypesProvider Namespace Lionk.Core.TypeRegister Assembly Lionk.Core.dll Interface which define a types provider. public interface ITypesProvider Methods GetTypes() Gets all types from the provider. IEnumerable<Type> GetTypes() Returns IEnumerable<Type> A collection of types. Events NewTypesAvailable Event raised when a new type is available. event EventHandler<TypesEventArgs> NewTypesAvailable Event Type EventHandler<TypesEventArgs>"
  },
  "api/Lionk.Core.TypeRegister.TypesEventArgs.html": {
    "href": "api/Lionk.Core.TypeRegister.TypesEventArgs.html",
    "title": "Class TypesEventArgs | Lionk",
    "keywords": "Class TypesEventArgs Namespace Lionk.Core.TypeRegister Assembly Lionk.Core.dll Provides data for the TypeAvailable event. public class TypesEventArgs : EventArgs Inheritance object EventArgs TypesEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the TypesEventArgs class. Constructors TypesEventArgs(IEnumerable<Type>) Provides data for the TypeAvailable event. public TypesEventArgs(IEnumerable<Type> type) Parameters type IEnumerable<Type> The new types that is available. Remarks Initializes a new instance of the TypesEventArgs class. Properties Types Gets the new types that is available. public IEnumerable<Type> Types { get; } Property Value IEnumerable<Type>"
  },
  "api/Lionk.Core.TypeRegister.html": {
    "href": "api/Lionk.Core.TypeRegister.html",
    "title": "Namespace Lionk.Core.TypeRegister | Lionk",
    "keywords": "Namespace Lionk.Core.TypeRegister Classes Factory Class that create instances of a type. TypesEventArgs Provides data for the TypeAvailable event. Interfaces ITypesProvider Interface which define a types provider."
  },
  "api/Lionk.Core.View.ComponentView.html": {
    "href": "api/Lionk.Core.View.ComponentView.html",
    "title": "Class ComponentView | Lionk",
    "keywords": "Class ComponentView Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll public class ComponentView : MudItem, IComponent, IHandleEvent, IHandleAfterRender, IMudStateHasChanged Inheritance object ComponentBase ComponentBaseWithState MudComponentBase MudItem ComponentView Implements IComponent IHandleEvent IHandleAfterRender IMudStateHasChanged Inherited Members MudItem.Classname MudItem.xs MudItem.sm MudItem.md MudItem.lg MudItem.xl MudItem.xxl MudItem.ChildContent MudComponentBase.OnAfterRender(bool) MudComponentBase.Logger MudComponentBase.Class MudComponentBase.Style MudComponentBase.Tag MudComponentBase.UserAttributes MudComponentBase.IsJSRuntimeAvailable MudComponentBase.FieldId ComponentBaseWithState.SetParametersAsync(ParameterView) ComponentBaseWithState.OnParametersSet() ComponentBaseWithState.CreateRegisterScope() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Component The component to show. [Parameter] public IComponent? Component { get; set; } Property Value IComponent ComponentViewModel The component view model. [Parameter] public ComponentViewModel? ComponentViewModel { get; set; } Property Value ComponentViewModel OnDelete Event that is called when the componentViewModel is deleted. [Parameter] public EventCallback<ComponentViewModel> OnDelete { get; set; } Property Value EventCallback<ComponentViewModel> OnUpdate Event that is called when the componentViewModel is updated. [Parameter] public EventCallback<ComponentViewModel> OnUpdate { get; set; } Property Value EventCallback<ComponentViewModel> Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. protected override void OnInitialized()"
  },
  "api/Lionk.Core.View.ComponentViewConfig.html": {
    "href": "api/Lionk.Core.View.ComponentViewConfig.html",
    "title": "Class ComponentViewConfig | Lionk",
    "keywords": "Class ComponentViewConfig Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll [ViewOf(\"Component base configuration\", typeof(IComponent), typeof(ComponentViewConfig), ViewContext.Configuration)] public class ComponentViewConfig : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase ComponentViewConfig Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Component The component to configure. [Parameter] public IComponent? Component { get; set; } Property Value IComponent Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.View.ComponentViewDescription.html": {
    "href": "api/Lionk.Core.View.ComponentViewDescription.html",
    "title": "Class ComponentViewDescription | Lionk",
    "keywords": "Class ComponentViewDescription Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll This class is used to define the link between a IComponent and a view depending on a ViewContext. public record ComponentViewDescription : IEquatable<ComponentViewDescription> Inheritance object ComponentViewDescription Implements IEquatable<ComponentViewDescription> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComponentViewDescription(string, Type, Type, ViewContext) This class is used to define the link between a IComponent and a view depending on a ViewContext. public ComponentViewDescription(string Name, Type ComponentType, Type ViewType, ViewContext ViewContext) Parameters Name string ComponentType Type ViewType Type ViewContext ViewContext Properties ComponentType public Type ComponentType { get; init; } Property Value Type Name public string Name { get; init; } Property Value string ViewContext public ViewContext ViewContext { get; init; } Property Value ViewContext ViewType public Type ViewType { get; init; } Property Value Type"
  },
  "api/Lionk.Core.View.ComponentViewModel.html": {
    "href": "api/Lionk.Core.View.ComponentViewModel.html",
    "title": "Class ComponentViewModel | Lionk",
    "keywords": "Class ComponentViewModel Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll Dashboard item model. public class ComponentViewModel Inheritance object ComponentViewModel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComponentViewModel(Guid, Guid, Type, int[]) Initializes a new instance of the ComponentViewModel class. [JsonConstructor] public ComponentViewModel(Guid id, Guid componentId, Type viewType, int[] indexes) Parameters id Guid The unique identifier of the dashboard item model. componentId Guid The component instance name. viewType Type The view type. indexes int[] The indexes of selected views. ComponentViewModel(Guid, Type) Initializes a new instance of the ComponentViewModel class. public ComponentViewModel(Guid componentId, Type viewType) Parameters componentId Guid The component unique id. viewType Type The view type. Properties ComponentUniqueId Gets or sets the component instance name. public Guid ComponentUniqueId { get; set; } Property Value Guid Id Gets the unique identifier of the dashboard history. public Guid Id { get; } Property Value Guid Indexes Gets the indexes of selected views. public int[] Indexes { get; } Property Value int[] ViewType Gets or sets the view type. public Type ViewType { get; set; } Property Value Type Methods SaveCurrentIndex(ViewContext, int) This method saves the current index of the view. public void SaveCurrentIndex(ViewContext viewContext, int index) Parameters viewContext ViewContext The view context. index int The index of the view."
  },
  "api/Lionk.Core.View.ContainerView.html": {
    "href": "api/Lionk.Core.View.ContainerView.html",
    "title": "Class ContainerView | Lionk",
    "keywords": "Class ContainerView Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll public class ContainerView : MudItem, IComponent, IHandleEvent, IHandleAfterRender, IMudStateHasChanged Inheritance object ComponentBase ComponentBaseWithState MudComponentBase MudItem ContainerView Implements IComponent IHandleEvent IHandleAfterRender IMudStateHasChanged Inherited Members MudItem.Classname MudItem.xs MudItem.sm MudItem.md MudItem.lg MudItem.xl MudItem.xxl MudItem.ChildContent MudComponentBase.OnAfterRender(bool) MudComponentBase.Logger MudComponentBase.Class MudComponentBase.Style MudComponentBase.Tag MudComponentBase.UserAttributes MudComponentBase.IsJSRuntimeAvailable MudComponentBase.FieldId ComponentBaseWithState.SetParametersAsync(ParameterView) ComponentBaseWithState.OnParametersSet() ComponentBaseWithState.CreateRegisterScope() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ComponentViewModel The component view model. [Parameter] public ComponentViewModel? ComponentViewModel { get; set; } Property Value ComponentViewModel OnDelete Event that is called when the componentViewModel is deleted. [Parameter] public EventCallback<ComponentViewModel> OnDelete { get; set; } Property Value EventCallback<ComponentViewModel> OnUpdate Event that is called when the componentViewModel is updated. [Parameter] public EventCallback<ComponentViewModel> OnUpdate { get; set; } Property Value EventCallback<ComponentViewModel> Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. protected override void OnInitialized()"
  },
  "api/Lionk.Core.View.CyclicComponentConfig.html": {
    "href": "api/Lionk.Core.View.CyclicComponentConfig.html",
    "title": "Class CyclicComponentConfig | Lionk",
    "keywords": "Class CyclicComponentConfig Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll [ViewOf(\"Cyclic component configuration\", typeof(ICyclicComponent), typeof(CyclicComponentConfig), ViewContext.Configuration)] public class CyclicComponentConfig : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase CyclicComponentConfig Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Component The cyclic component to configure. [Parameter] public ICyclicComponent? Component { get; set; } Property Value ICyclicComponent Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.View.CyclicComputationMethodExtensionInformation.html": {
    "href": "api/Lionk.Core.View.CyclicComputationMethodExtensionInformation.html",
    "title": "Class CyclicComputationMethodExtensionInformation | Lionk",
    "keywords": "Class CyclicComputationMethodExtensionInformation Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll This class defines the information for the CyclicComputationMethod enumeration. public static class CyclicComputationMethodExtensionInformation Inheritance object CyclicComputationMethodExtensionInformation Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetDescription(CyclicComputationMethod) This method returns the description of the CyclicComputationMethod enumeration. public static string GetDescription(this CyclicComputationMethod method) Parameters method CyclicComputationMethod The cyclic computation method. Returns string The description. ToFriendlyString(CyclicComputationMethod) This method returns the friendly string representation of the CyclicComputationMethod enumeration. public static string ToFriendlyString(this CyclicComputationMethod method) Parameters method CyclicComputationMethod The cyclic computation method. Returns string The friendly string representation. Exceptions ArgumentOutOfRangeException Thrown when the method is not recognized."
  },
  "api/Lionk.Core.View.DynamicComponentWrapper.html": {
    "href": "api/Lionk.Core.View.DynamicComponentWrapper.html",
    "title": "Class DynamicComponentWrapper | Lionk",
    "keywords": "Class DynamicComponentWrapper Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll public class DynamicComponentWrapper : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender, IDisposable Inheritance object ComponentBase DynamicComponentWrapper Implements IComponent IHandleEvent IHandleAfterRender IDisposable Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Parameters Parameter for the parameters of the view to be displayed. [Parameter] public IDictionary<string, object>? Parameters { get; set; } Property Value IDictionary<string, object> Type Parameter for the type of the view to be displayed. [Parameter] public Type? Type { get; set; } Property Value Type Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder Dispose() Provides a mechanism for releasing unmanaged resources. public void Dispose() OnAfterRender(bool) protected override void OnAfterRender(bool firstRender) Parameters firstRender bool"
  },
  "api/Lionk.Core.View.IViewLocatorService.html": {
    "href": "api/Lionk.Core.View.IViewLocatorService.html",
    "title": "Interface IViewLocatorService | Lionk",
    "keywords": "Interface IViewLocatorService Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll Interface which define the service to locate the view of a component. public interface IViewLocatorService : IDisposable Inherited Members IDisposable.Dispose() Methods GetViewOf(Type, ViewContext) Get the view of a component depending on the context. IEnumerable<ComponentViewDescription> GetViewOf(Type type, ViewContext context) Parameters type Type The type of the component. context ViewContext The context. Returns IEnumerable<ComponentViewDescription> A Type which define the view."
  },
  "api/Lionk.Core.View.IViewRegistryService.html": {
    "href": "api/Lionk.Core.View.IViewRegistryService.html",
    "title": "Interface IViewRegistryService | Lionk",
    "keywords": "Interface IViewRegistryService Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll Interface which define the service to register the active views. public interface IViewRegistryService Methods HasActiveViews(Type) Method used to check if an instance of the view is active. bool HasActiveViews(Type t) Parameters t Type Returns bool True if an instance of this type exist. Register(object) Method used to register a view. void Register(object viewInstance) Parameters viewInstance object The view instance. Unregister(object) Method used to unregister a view. void Unregister(object viewInstance) Parameters viewInstance object The view instance."
  },
  "api/Lionk.Core.View.LoadingComponent.html": {
    "href": "api/Lionk.Core.View.LoadingComponent.html",
    "title": "Class LoadingComponent | Lionk",
    "keywords": "Class LoadingComponent Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll public class LoadingComponent : MudItem, IComponent, IHandleEvent, IHandleAfterRender, IMudStateHasChanged Inheritance object ComponentBase ComponentBaseWithState MudComponentBase MudItem LoadingComponent Implements IComponent IHandleEvent IHandleAfterRender IMudStateHasChanged Inherited Members MudItem.OnInitialized() MudItem.Classname MudItem.xs MudItem.sm MudItem.md MudItem.lg MudItem.xl MudItem.xxl MudItem.ChildContent MudComponentBase.OnAfterRender(bool) MudComponentBase.Logger MudComponentBase.Class MudComponentBase.Style MudComponentBase.Tag MudComponentBase.UserAttributes MudComponentBase.IsJSRuntimeAvailable MudComponentBase.FieldId ComponentBaseWithState.SetParametersAsync(ParameterView) ComponentBaseWithState.OnParametersSet() ComponentBaseWithState.CreateRegisterScope() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ComponentViewModel The component view model. [Parameter] public ComponentViewModel? ComponentViewModel { get; set; } Property Value ComponentViewModel OnDelete Event that is called when the Delete button is clicked. [Parameter] public EventCallback<ComponentViewModel> OnDelete { get; set; } Property Value EventCallback<ComponentViewModel> Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.View.NoComponentView.html": {
    "href": "api/Lionk.Core.View.NoComponentView.html",
    "title": "Class NoComponentView | Lionk",
    "keywords": "Class NoComponentView Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll public class NoComponentView : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase NoComponentView Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Text The text to show when no component is available. [Parameter] public string Text { get; set; } Property Value string Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Core.View.ViewContext.html": {
    "href": "api/Lionk.Core.View.ViewContext.html",
    "title": "Enum ViewContext | Lionk",
    "keywords": "Enum ViewContext Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll This enum is used to specify the view that is used to configure the object. public enum ViewContext Fields Configuration = 0 Defines the view as a configuration view. Detail = 1 Defines the view as a detail view. Page = 2 Defines the view as a page view. Widget = 3 Defines the view as a widget view."
  },
  "api/Lionk.Core.View.ViewLocatorService.html": {
    "href": "api/Lionk.Core.View.ViewLocatorService.html",
    "title": "Class ViewLocatorService | Lionk",
    "keywords": "Class ViewLocatorService Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll This class is used to locate the view of a component. public class ViewLocatorService : IViewLocatorService, IDisposable Inheritance object ViewLocatorService Implements IViewLocatorService IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ViewLocatorService(ITypesProvider) Initializes a new instance of the ViewLocatorService class. public ViewLocatorService(ITypesProvider provider) Parameters provider ITypesProvider The views provider. Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetViewOf(Type, ViewContext) Get the view of a component depending on the context. public IEnumerable<ComponentViewDescription> GetViewOf(Type type, ViewContext context) Parameters type Type The type of the component. context ViewContext The context. Returns IEnumerable<ComponentViewDescription> A Type which define the view."
  },
  "api/Lionk.Core.View.ViewOfAttribute.html": {
    "href": "api/Lionk.Core.View.ViewOfAttribute.html",
    "title": "Class ViewOfAttribute | Lionk",
    "keywords": "Class ViewOfAttribute Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll This attribute is used to specify the view that is used to configure the object. [AttributeUsage(AttributeTargets.Class)] public class ViewOfAttribute : Attribute Inheritance object Attribute ViewOfAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the ViewOfAttribute class. Constructors ViewOfAttribute(string, Type, Type, ViewContext) This attribute is used to specify the view that is used to configure the object. public ViewOfAttribute(string name, Type componentType, Type configurableView, ViewContext viewMode) Parameters name string The name of the view. componentType Type The type of the object that is being configured. configurableView Type The type of the view that is used to configure the object. viewMode ViewContext The view mode that is used to configure the object. Remarks Initializes a new instance of the ViewOfAttribute class. Properties Description Gets the description of the view. public ComponentViewDescription Description { get; } Property Value ComponentViewDescription"
  },
  "api/Lionk.Core.View.ViewRegistryService.html": {
    "href": "api/Lionk.Core.View.ViewRegistryService.html",
    "title": "Class ViewRegistryService | Lionk",
    "keywords": "Class ViewRegistryService Namespace Lionk.Core.View Assembly Lionk.Core.Razor.dll Service which register the active views. public class ViewRegistryService : IViewRegistryService Inheritance object ViewRegistryService Implements IViewRegistryService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods HasActiveViews(Type) Interface which define the service to register the active views. public bool HasActiveViews(Type t) Parameters t Type Returns bool Register(object) Interface which define the service to register the active views. public void Register(object viewInstance) Parameters viewInstance object Unregister(object) Interface which define the service to register the active views. public void Unregister(object viewInstance) Parameters viewInstance object"
  },
  "api/Lionk.Core.View.html": {
    "href": "api/Lionk.Core.View.html",
    "title": "Namespace Lionk.Core.View | Lionk",
    "keywords": "Namespace Lionk.Core.View Classes ComponentView ComponentViewConfig ComponentViewDescription This class is used to define the link between a IComponent and a view depending on a ViewContext. ComponentViewModel Dashboard item model. ContainerView CyclicComponentConfig CyclicComputationMethodExtensionInformation This class defines the information for the CyclicComputationMethod enumeration. DynamicComponentWrapper LoadingComponent NoComponentView ViewLocatorService This class is used to locate the view of a component. ViewOfAttribute This attribute is used to specify the view that is used to configure the object. ViewRegistryService Service which register the active views. Interfaces IViewLocatorService Interface which define the service to locate the view of a component. IViewRegistryService Interface which define the service to register the active views. Enums ViewContext This enum is used to specify the view that is used to configure the object."
  },
  "api/Lionk.Core.html": {
    "href": "api/Lionk.Core.html",
    "title": "Namespace Lionk.Core | Lionk",
    "keywords": "Namespace Lionk.Core Classes NamedElement Attribute to define the name of a viewable component."
  },
  "api/Lionk.Log.ILoggerFactory.html": {
    "href": "api/Lionk.Log.ILoggerFactory.html",
    "title": "Interface ILoggerFactory | Lionk",
    "keywords": "Interface ILoggerFactory Namespace Lionk.Log Assembly Lionk.Logger.dll Interface for creating loggers. public interface ILoggerFactory Methods CreateLogger(string) Create a logger. IStandardLogger CreateLogger(string loggerName) Parameters loggerName string The logger name. Returns IStandardLogger A new IStandardLogger."
  },
  "api/Lionk.Log.IStandardLogger.html": {
    "href": "api/Lionk.Log.IStandardLogger.html",
    "title": "Interface IStandardLogger | Lionk",
    "keywords": "Interface IStandardLogger Namespace Lionk.Log Assembly Lionk.Logger.dll Interface for custom logger. public interface IStandardLogger : IDisposable Inherited Members IDisposable.Dispose() Methods Log(LogSeverity, string) Log a message with a LogSeverity. void Log(LogSeverity severity, string message) Parameters severity LogSeverity The severity. message string The message to log."
  },
  "api/Lionk.Log.LogService.html": {
    "href": "api/Lionk.Log.LogService.html",
    "title": "Class LogService | Lionk",
    "keywords": "Class LogService Namespace Lionk.Log Assembly Lionk.Logger.dll Static class for logging this class must be used to log messages and create loggers. public static class LogService Inheritance object LogService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Configure(ILoggerFactory) Configure the logger. public static void Configure(ILoggerFactory loggerFactory) Parameters loggerFactory ILoggerFactory The logger factory. Exceptions ArgumentNullException Throw an argument null exception if loggerFactory is null. CreateLogger(string) Create a new IStandardLogger. public static IStandardLogger? CreateLogger(string loggerName) Parameters loggerName string The name of the logger. Returns IStandardLogger A new IStandardLogger. LogApp(LogSeverity, string) Log an application message. public static void LogApp(LogSeverity severity, string message) Parameters severity LogSeverity Log severity. message string Log message. LogDebug(string) Log a debug message. public static void LogDebug(string message) Parameters message string Debug message."
  },
  "api/Lionk.Log.LogSeverity.html": {
    "href": "api/Lionk.Log.LogSeverity.html",
    "title": "Enum LogSeverity | Lionk",
    "keywords": "Enum LogSeverity Namespace Lionk.Log Assembly Lionk.Logger.dll Log severity enum. public enum LogSeverity Fields Critical = 5 Fatal log severity. Debug = 1 Debug log severity. Error = 4 Error log severity. Information = 2 Information log severity. Trace = 0 Trace log severity. Warning = 3 Warning log severity."
  },
  "api/Lionk.Log.Serilog.SerilogFactory.html": {
    "href": "api/Lionk.Log.Serilog.SerilogFactory.html",
    "title": "Class SerilogFactory | Lionk",
    "keywords": "Class SerilogFactory Namespace Lionk.Log.Serilog Assembly Lionk.Logger.dll A factory for creating Serilog loggers. public class SerilogFactory : ILoggerFactory Inheritance object SerilogFactory Implements ILoggerFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateLogger(string) Create a logger. public IStandardLogger CreateLogger(string loggerName) Parameters loggerName string The logger name. Returns IStandardLogger A new IStandardLogger."
  },
  "api/Lionk.Log.Serilog.html": {
    "href": "api/Lionk.Log.Serilog.html",
    "title": "Namespace Lionk.Log.Serilog | Lionk",
    "keywords": "Namespace Lionk.Log.Serilog Classes SerilogFactory A factory for creating Serilog loggers."
  },
  "api/Lionk.Log.Utils.html": {
    "href": "api/Lionk.Log.Utils.html",
    "title": "Class Utils | Lionk",
    "keywords": "Class Utils Namespace Lionk.Log Assembly Lionk.Logger.dll Utils static class for logging. public static class Utils Inheritance object Utils Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields LogExtension The extension for the log files. public const string LogExtension = \".log\" Field Value string"
  },
  "api/Lionk.Log.html": {
    "href": "api/Lionk.Log.html",
    "title": "Namespace Lionk.Log | Lionk",
    "keywords": "Namespace Lionk.Log Classes LogService Static class for logging this class must be used to log messages and create loggers. Utils Utils static class for logging. Interfaces ILoggerFactory Interface for creating loggers. IStandardLogger Interface for custom logger. Enums LogSeverity Log severity enum."
  },
  "api/Lionk.Notification.Content.html": {
    "href": "api/Lionk.Notification.Content.html",
    "title": "Class Content | Lionk",
    "keywords": "Class Content Namespace Lionk.Notification Assembly Lionk.Notification.dll This class represents the content of a notification. public class Content Inheritance object Content Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Content(Severity, string, string) Initializes a new instance of the Content class. public Content(Severity level, string title, string message) Parameters level Severity The severity level of the notification. title string The title of the notification. message string The message of the notification. Properties Level Gets the severity level of the notification. public Severity Level { get; } Property Value Severity Message Gets the message of the notification. public string Message { get; } Property Value string Title Gets the title of the notification. public string Title { get; } Property Value string"
  },
  "api/Lionk.Notification.Converter.NotificationPropertiesConverter.html": {
    "href": "api/Lionk.Notification.Converter.NotificationPropertiesConverter.html",
    "title": "Class NotificationPropertiesConverter | Lionk",
    "keywords": "Class NotificationPropertiesConverter Namespace Lionk.Notification.Converter Assembly Lionk.Notification.dll This class is used to convert a notifier. public class NotificationPropertiesConverter : JsonConverter Inheritance object JsonConverter NotificationPropertiesConverter Inherited Members JsonConverter.CanRead JsonConverter.CanWrite object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanConvert(Type) Determines whether this instance can convert the specified object type. public override bool CanConvert(Type objectType) Parameters objectType Type Type of the object. Returns bool true if this instance can convert the specified object type; otherwise, false. GetFullType(string) Gets the type of the object. protected Type? GetFullType(string typeName) Parameters typeName string The name of the type. Returns Type The type of the object. ReadJson(JsonReader, Type, object?, JsonSerializer) Reads the JSON representation of the object. public override object ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer) Parameters reader JsonReader The Newtonsoft.Json.JsonReader to read from. objectType Type Type of the object. existingValue object The existing value of object being read. serializer JsonSerializer The calling serializer. Returns object The object value. WriteJson(JsonWriter, object?, JsonSerializer) Writes the JSON representation of the object. public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer) Parameters writer JsonWriter The Newtonsoft.Json.JsonWriter to write to. value object The value. serializer JsonSerializer The calling serializer."
  },
  "api/Lionk.Notification.Converter.NotifierChannelDictionaryConverter.html": {
    "href": "api/Lionk.Notification.Converter.NotifierChannelDictionaryConverter.html",
    "title": "Class NotifierChannelDictionaryConverter | Lionk",
    "keywords": "Class NotifierChannelDictionaryConverter Namespace Lionk.Notification.Converter Assembly Lionk.Notification.dll This class is used to convert a dictionary of Notifier and Channels to a json object. public class NotifierChannelDictionaryConverter : JsonConverter Inheritance object JsonConverter NotifierChannelDictionaryConverter Inherited Members JsonConverter.CanRead JsonConverter.CanWrite object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CanConvert(Type) Determines whether this instance can convert the specified object type. public override bool CanConvert(Type objectType) Parameters objectType Type Type of the object. Returns bool true if this instance can convert the specified object type; otherwise, false. ReadJson(JsonReader, Type, object?, JsonSerializer) Reads the JSON representation of the object. public override object ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer) Parameters reader JsonReader The Newtonsoft.Json.JsonReader to read from. objectType Type Type of the object. existingValue object The existing value of object being read. serializer JsonSerializer The calling serializer. Returns object The object value. WriteJson(JsonWriter, object?, JsonSerializer) Writes the JSON representation of the object. public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer) Parameters writer JsonWriter The Newtonsoft.Json.JsonWriter to write to. value object The value. serializer JsonSerializer The calling serializer."
  },
  "api/Lionk.Notification.Converter.html": {
    "href": "api/Lionk.Notification.Converter.html",
    "title": "Namespace Lionk.Notification.Converter | Lionk",
    "keywords": "Namespace Lionk.Notification.Converter Classes NotificationPropertiesConverter This class is used to convert a notifier. NotifierChannelDictionaryConverter This class is used to convert a dictionary of Notifier and Channels to a json object."
  },
  "api/Lionk.Notification.Email.EmailChannel.html": {
    "href": "api/Lionk.Notification.Email.EmailChannel.html",
    "title": "Class EmailChannel | Lionk",
    "keywords": "Class EmailChannel Namespace Lionk.Notification.Email Assembly Lionk.Notification.dll This class define an email channel. public class EmailChannel : IChannel, IEquatable<IChannel> Inheritance object EmailChannel Implements IChannel IEquatable<IChannel> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors EmailChannel(Guid, string, List<IRecipient>, SmtpConfig, bool) Initializes a new instance of the EmailChannel class. [JsonConstructor] public EmailChannel(Guid guid, string name, List<IRecipient> recipients, SmtpConfig smtpConfig, bool isInitialized) Parameters guid Guid The Guid of the channel. name string The name of the channel. recipients List<IRecipient> The list of recipients. smtpConfig SmtpConfig The SMTP configuration. isInitialized bool A value indicating whether the channel is initialized. EmailChannel(string) Initializes a new instance of the EmailChannel class. public EmailChannel(string name) Parameters name string The name of the channel. EmailChannel(string, LinkedList<IRecipient>) Initializes a new instance of the EmailChannel class. public EmailChannel(string name, LinkedList<IRecipient> recipients) Parameters name string The name of the channel. recipients LinkedList<IRecipient> The list of recipients. Properties Guid Gets the Guid of the channel. public Guid Guid { get; } Property Value Guid IsInitialized Gets a value indicating whether the channel is initialized. [JsonIgnore] public bool IsInitialized { get; } Property Value bool Name Gets the name of the channel. public string Name { get; } Property Value string Recipients Gets the recipients of the channel. public List<IRecipient> Recipients { get; } Property Value List<IRecipient> SmtpConfig Gets the SMTP configuration. public SmtpConfig SmtpConfig { get; } Property Value SmtpConfig Methods AddRecipients(params IRecipient[]) This method add one or more recipients to the channel. public void AddRecipients(params IRecipient[] recipients) Parameters recipients IRecipient[] The recipient to add. Equals(IChannel?) Defines a generalized method that a value type or class implements to create a type-specific method for determining equality of instances. public bool Equals(IChannel? obj) Parameters obj IChannel Returns bool Initialize() Initialize the channel to send notifications. public void Initialize() Send(INotifier, Content) Send a notification to the specified recipients. public void Send(INotifier notifier, Content content) Parameters notifier INotifier The notifier that send the notification. content Content The content of the notification. SetSmtpConfiguration(string, int, bool, string, string) Method used to create the SMTP configuration file. public void SetSmtpConfiguration(string smtpServer, int port, bool enableSsl, string username, string password) Parameters smtpServer string The SMTP server. port int The port of the SMTP server. enableSsl bool A value indicating whether the SSL is enabled. username string The username used to authenticate to the SMTP server. password string The password used to authenticate to the SMTP server."
  },
  "api/Lionk.Notification.Email.EmailRecipients.html": {
    "href": "api/Lionk.Notification.Email.EmailRecipients.html",
    "title": "Class EmailRecipients | Lionk",
    "keywords": "Class EmailRecipients Namespace Lionk.Notification.Email Assembly Lionk.Notification.dll This class define an email recipients to send notifications. public class EmailRecipients : IRecipient Inheritance object EmailRecipients Implements IRecipient Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors EmailRecipients() Initializes a new instance of the EmailRecipients class. public EmailRecipients() EmailRecipients(Guid, string, string) Initializes a new instance of the EmailRecipients class with the specified Guid, name, and email. [JsonConstructor] public EmailRecipients(Guid guid, string name, string email) Parameters guid Guid The Guid of the recipient. name string The name of the recipient. email string The email of the recipient. EmailRecipients(string, string) Initializes a new instance of the EmailRecipients class with the specified name, email, subject, and body. public EmailRecipients(string name, string email) Parameters name string The name of the recipient. email string The email of the recipient. Properties Email Gets the email of the recipient. public string Email { get; } Property Value string Guid Gets the Guid of the channel. public Guid Guid { get; } Property Value Guid Name Gets the name of the recipient. public string Name { get; } Property Value string"
  },
  "api/Lionk.Notification.Email.SmtpConfig.html": {
    "href": "api/Lionk.Notification.Email.SmtpConfig.html",
    "title": "Class SmtpConfig | Lionk",
    "keywords": "Class SmtpConfig Namespace Lionk.Notification.Email Assembly Lionk.Notification.dll This class define the configuration of the SMTP server. public class SmtpConfig Inheritance object SmtpConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties EnableSsl Gets or sets a value indicating whether the SSL is enabled. public bool EnableSsl { get; set; } Property Value bool Password Gets or sets the password used to authenticate to the SMTP server. public string Password { get; set; } Property Value string Port Gets or Sets the port of the SMTP port. public int Port { get; set; } Property Value int SmtpServer Gets or sets The SMTP server. public string SmtpServer { get; set; } Property Value string Username Gets or sets the username used to authenticate to the SMTP server. public string Username { get; set; } Property Value string"
  },
  "api/Lionk.Notification.Email.html": {
    "href": "api/Lionk.Notification.Email.html",
    "title": "Namespace Lionk.Notification.Email | Lionk",
    "keywords": "Namespace Lionk.Notification.Email Classes EmailChannel This class define an email channel. EmailRecipients This class define an email recipients to send notifications. SmtpConfig This class define the configuration of the SMTP server."
  },
  "api/Lionk.Notification.Event.NotificationEventArgs.html": {
    "href": "api/Lionk.Notification.Event.NotificationEventArgs.html",
    "title": "Class NotificationEventArgs | Lionk",
    "keywords": "Class NotificationEventArgs Namespace Lionk.Notification.Event Assembly Lionk.Notification.dll This class is used to store the event arguments of a notification. public class NotificationEventArgs : EventArgs Inheritance object EventArgs NotificationEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NotificationEventArgs(Notification, List<IChannel>) Initializes a new instance of the NotificationEventArgs class. public NotificationEventArgs(Notification notification, List<IChannel> channels) Parameters notification Notification The notification that was sent. channels List<IChannel> The channels where the notification was sent. Properties Channels Gets the channels where the notification was sent. public List<IChannel> Channels { get; } Property Value List<IChannel> Notification Gets the notification that was sent. public Notification Notification { get; } Property Value Notification"
  },
  "api/Lionk.Notification.Event.html": {
    "href": "api/Lionk.Notification.Event.html",
    "title": "Namespace Lionk.Notification.Event | Lionk",
    "keywords": "Namespace Lionk.Notification.Event Classes NotificationEventArgs This class is used to store the event arguments of a notification."
  },
  "api/Lionk.Notification.IChannel.html": {
    "href": "api/Lionk.Notification.IChannel.html",
    "title": "Interface IChannel | Lionk",
    "keywords": "Interface IChannel Namespace Lionk.Notification Assembly Lionk.Notification.dll Interface that define a Notification Channel. public interface IChannel : IEquatable<IChannel> Properties Guid Gets the Guid of the channel. Guid Guid { get; } Property Value Guid IsInitialized Gets a value indicating whether the channel is initialized. bool IsInitialized { get; } Property Value bool Name Gets the name of the channel. string Name { get; } Property Value string Recipients Gets the recipients of the channel. List<IRecipient> Recipients { get; } Property Value List<IRecipient> Methods AddRecipients(params IRecipient[]) This method add one or more recipients to the channel. void AddRecipients(params IRecipient[] recipients) Parameters recipients IRecipient[] The recipient to add. Equals(IChannel?) Method to compare two objects. bool Equals(IChannel? obj) Parameters obj IChannel The object to compare. Returns bool True if the objects are equals, otherwise false. Initialize() Initialize the channel to send notifications. void Initialize() Send(INotifier, Content) Send a notification to the specified recipients. void Send(INotifier notifier, Content content) Parameters notifier INotifier The notifier that send the notification. content Content The content of the notification."
  },
  "api/Lionk.Notification.INotifier.html": {
    "href": "api/Lionk.Notification.INotifier.html",
    "title": "Interface INotifier | Lionk",
    "keywords": "Interface INotifier Namespace Lionk.Notification Assembly Lionk.Notification.dll This interface represents a notifier that can send notifications. public interface INotifier : IEquatable<INotifier> Properties Id Gets the Guid of the notifier. Guid Id { get; } Property Value Guid Name Gets the name of the notifier. string Name { get; } Property Value string Methods Equals(INotifier?) Method to compare two objects. bool Equals(INotifier? obj) Parameters obj INotifier The object to compare. Returns bool A value indicating whether the objects are equal."
  },
  "api/Lionk.Notification.IRecipient.html": {
    "href": "api/Lionk.Notification.IRecipient.html",
    "title": "Interface IRecipient | Lionk",
    "keywords": "Interface IRecipient Namespace Lionk.Notification Assembly Lionk.Notification.dll Interface that define a recipient to send notifications. public interface IRecipient Properties Guid Gets the Guid of the channel. Guid Guid { get; } Property Value Guid Name Gets the name of the recipient. string Name { get; } Property Value string"
  },
  "api/Lionk.Notification.Notification.html": {
    "href": "api/Lionk.Notification.Notification.html",
    "title": "Class Notification | Lionk",
    "keywords": "Class Notification Namespace Lionk.Notification Assembly Lionk.Notification.dll This class represents a notification that can be displayed to the user. public class Notification Inheritance object Notification Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Notification(Content, INotifier) Initializes a new instance of the Notification class. public Notification(Content content, INotifier notifier) Parameters content Content The content of the notification. notifier INotifier The notifier that sent the notification. Notification(Guid, Content, INotifier, DateTime) Initializes a new instance of the Notification class. [JsonConstructor] public Notification(Guid id, Content content, INotifier notifier, DateTime timestamp) Parameters id Guid The unique identifier of the notification. content Content The content of the notification. notifier INotifier The notifier that sent the notification. timestamp DateTime The timestamp when the notification was created. Properties Content Gets the content of the notification. public Content Content { get; } Property Value Content Id Gets the unique identifier of the notification. public Guid Id { get; } Property Value Guid Notifier Gets the notifier that sent the notification. public INotifier Notifier { get; } Property Value INotifier Timestamp Gets the timestamp when the notification was created. public DateTime Timestamp { get; } Property Value DateTime"
  },
  "api/Lionk.Notification.NotificationFileHandler.html": {
    "href": "api/Lionk.Notification.NotificationFileHandler.html",
    "title": "Class NotificationFileHandler | Lionk",
    "keywords": "Class NotificationFileHandler Namespace Lionk.Notification Assembly Lionk.Notification.dll This class implements the way notifications are managed with a file. public static class NotificationFileHandler Inheritance object NotificationFileHandler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods EditNotificationHistory(NotificationHistory) Method to edit a notification in history. public static void EditNotificationHistory(NotificationHistory notificationHistory) Parameters notificationHistory NotificationHistory The notification to edit. GetChannelsFromJson() Method to get channels from a file. public static List<IChannel> GetChannelsFromJson() Returns List<IChannel> The list of channels. GetNotificationByGuid(Guid) Method to get a notification by its unique identifier. public static NotificationHistory? GetNotificationByGuid(Guid guid) Parameters guid Guid The unique identifier of the notification. Returns NotificationHistory The notification with the specified unique identifier. GetNotifications() Method to get all the notifications saved. public static List<NotificationHistory> GetNotifications() Returns List<NotificationHistory> The list of notifications saved. Exceptions ArgumentNullException If file exists but the result of the deserialization is null. GetNotifierChannelsFromJSon() Method to get notifier channels dictionary from a file. public static Dictionary<Guid, List<IChannel>> GetNotifierChannelsFromJSon() Returns Dictionary<Guid, List<IChannel>> The dictionary of notifiers and channels. GetNotifiersFromJson() Method to get notifiers from a file. public static List<INotifier> GetNotifiersFromJson() Returns List<INotifier> The list of notifiers. SaveChannelToJson(List<IChannel>) Method to save channels to a file. public static void SaveChannelToJson(List<IChannel> channels) Parameters channels List<IChannel> The list of channels to save. SaveNotification(NotificationHistory) Method to save a notification in history. public static void SaveNotification(NotificationHistory notification) Parameters notification NotificationHistory The notification to save. SaveNotifierChannelsToJson(Dictionary<Guid, List<IChannel>>) Method to save notifier channels dictionary to a file. public static void SaveNotifierChannelsToJson(Dictionary<Guid, List<IChannel>> notifierChannels) Parameters notifierChannels Dictionary<Guid, List<IChannel>> The dictionary of notifiers and channels to save. SaveNotifierToJson(List<INotifier>) Method to save notifiers to a file. public static void SaveNotifierToJson(List<INotifier> notifiers) Parameters notifiers List<INotifier> The list of notifiers to save."
  },
  "api/Lionk.Notification.NotificationHistory.html": {
    "href": "api/Lionk.Notification.NotificationHistory.html",
    "title": "Class NotificationHistory | Lionk",
    "keywords": "Class NotificationHistory Namespace Lionk.Notification Assembly Lionk.Notification.dll This class represents the history of notifications. public class NotificationHistory Inheritance object NotificationHistory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NotificationHistory(Notification, List<IChannel>) Initializes a new instance of the NotificationHistory class. public NotificationHistory(Notification notification, List<IChannel> channels) Parameters notification Notification The notification. channels List<IChannel> The list of channels. NotificationHistory(Guid, Notification, List<IChannel>, bool) Initializes a new instance of the NotificationHistory class. [JsonConstructor] public NotificationHistory(Guid id, Notification notification, List<IChannel> channels, bool isRead) Parameters id Guid The GUID of the notification history. notification Notification The notification. channels List<IChannel> The list of channels. isRead bool The value indicating whether the notification is read. Properties Channels Gets the list of channels. public List<IChannel> Channels { get; } Property Value List<IChannel> Id Gets the unique identifier of the notification history. public Guid Id { get; } Property Value Guid IsRead Gets a value indicating whether the notification is active. public bool IsRead { get; } Property Value bool Notification Gets or sets the notification. public Notification Notification { get; set; } Property Value Notification Methods Read() This method marks the notification as read. public void Read() Unread() This method marks the notification as unread. public void Unread()"
  },
  "api/Lionk.Notification.NotificationService.html": {
    "href": "api/Lionk.Notification.NotificationService.html",
    "title": "Class NotificationService | Lionk",
    "keywords": "Class NotificationService Namespace Lionk.Notification Assembly Lionk.Notification.dll this class implements the way notifications are saved. public static class NotificationService Inheritance object NotificationService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Channels Gets the list of all the channels. public static ReadOnlyCollection<IChannel> Channels { get; } Property Value ReadOnlyCollection<IChannel> NotifierChannels Gets a Dictionary that maps the Notifier name with multiple channels. public static ReadOnlyDictionary<Guid, List<IChannel>> NotifierChannels { get; } Property Value ReadOnlyDictionary<Guid, List<IChannel>> Notifiers Gets get the list of all the notifiers. public static ReadOnlyCollection<INotifier> Notifiers { get; } Property Value ReadOnlyCollection<INotifier> Methods AddChannels(params IChannel[]) This method adds channels to the list of channels if they are not already in the list. public static void AddChannels(params IChannel[] channels) Parameters channels IChannel[] The channels to add. AddNotifiers(params INotifier[]) This method adds notifiers to the list of notifiers if they are not already in the list. public static void AddNotifiers(params INotifier[] notifiers) Parameters notifiers INotifier[] The notifiers to add. EditNotificationHistory(NotificationHistory) Edit a notification in history. public static void EditNotificationHistory(NotificationHistory notificationHistory) Parameters notificationHistory NotificationHistory The notification history to edit. GetNotificationByGuid(Guid) Get a notification by its unique identifier. public static NotificationHistory? GetNotificationByGuid(Guid guid) Parameters guid Guid the unique identifier of the notification. Returns NotificationHistory The notification with the specified unique identifier. GetNotifications() Get all the notifications saved. public static List<NotificationHistory> GetNotifications() Returns List<NotificationHistory> The list of notifications saved. GetUnreadNotificationCount() Get the unread notifications count. public static int GetUnreadNotificationCount() Returns int The list of unread notifications. MapNotifierToChannel(INotifier, params IChannel[]) Map a notifier to a channel and add them to the list of Notifiers and Channels if they are not already in the list. If the notifier is already mapped to the channel, the channels will be added if they are not already in the list. public static void MapNotifierToChannel(INotifier notifier, params IChannel[] channels) Parameters notifier INotifier The notifier to map. channels IChannel[] The list of channels to map. RemoveChannel(IChannel) Methode to remove a channel from the list of channels. If the channel is mapped to a notifier, it will be removed from the notifier. public static void RemoveChannel(IChannel channel) Parameters channel IChannel The channel to remove. RemoveNotifier(INotifier) This method removes a notifier from the list of notifiers. public static void RemoveNotifier(INotifier notifier) Parameters notifier INotifier The notifier to remove. SaveNotificationHistory(Notification) Save a notification in history. public static void SaveNotificationHistory(Notification notification) Parameters notification Notification The notification to save. Send(Notification) This method sends a notification and raises the event. public static void Send(Notification notification) Parameters notification Notification the notification to send. UnmapNotifierFromChannel(INotifier, params IChannel[]) Unmap a notifier from a list of channels. Removes the channels from the list of channels associated with the notifier. public static void UnmapNotifierFromChannel(INotifier notifier, params IChannel[] channels) Parameters notifier INotifier The notifier to unmap. channels IChannel[] The list of channels to unmap. WhoUseThisChannel(IChannel) Methode that returns the list of notifiers that use a channel. public static List<INotifier> WhoUseThisChannel(IChannel channel) Parameters channel IChannel The channel to check. Returns List<INotifier> The list of notifiers that use the channel. Events NotificationSent This event is raised when a notification is sent. public static event EventHandler<NotificationEventArgs>? NotificationSent Event Type EventHandler<NotificationEventArgs>"
  },
  "api/Lionk.Notification.Severity.html": {
    "href": "api/Lionk.Notification.Severity.html",
    "title": "Enum Severity | Lionk",
    "keywords": "Enum Severity Namespace Lionk.Notification Assembly Lionk.Notification.dll This enum define the level of a notification. public enum Severity Fields Debug = 1 Used for application debugging purposes and to inspect run-time outcomes in development environments. Error = 4 The most helpful, and yet the most unwanted, log level. Enables detailed error tracking and helps to write error-free applications. Fatal = 5 The most important log level, used to log critical system operations or outcomes that require urgent attention. Information = 2 Used for application monitoring and to track request and response details or specific operation results. Verbose = 0 The lowest log level, enable detailed trace logging mainly for application troubleshooting. Warning = 3 Used to review potential non-critical, non-friendly operation outcomes."
  },
  "api/Lionk.Notification.html": {
    "href": "api/Lionk.Notification.html",
    "title": "Namespace Lionk.Notification | Lionk",
    "keywords": "Namespace Lionk.Notification Classes Content This class represents the content of a notification. Notification This class represents a notification that can be displayed to the user. NotificationFileHandler This class implements the way notifications are managed with a file. NotificationHistory This class represents the history of notifications. NotificationService this class implements the way notifications are saved. Interfaces IChannel Interface that define a Notification Channel. INotifier This interface represents a notifier that can send notifications. IRecipient Interface that define a recipient to send notifications. Enums Severity This enum define the level of a notification."
  },
  "api/Lionk.Plugin.Blazor.FileUploadService.html": {
    "href": "api/Lionk.Plugin.Blazor.FileUploadService.html",
    "title": "Class FileUploadService | Lionk",
    "keywords": "Class FileUploadService Namespace Lionk.Plugin.Blazor Assembly Lionk.Plugin.Blazor.dll Service to upload files. public class FileUploadService Inheritance object FileUploadService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the FileUploadService class. Constructors FileUploadService(string) Service to upload files. public FileUploadService(string targetFilePath) Parameters targetFilePath string The target path where file will be saved. Remarks Initializes a new instance of the FileUploadService class. Methods UploadFileAsync(IReadOnlyList<IBrowserFile>) Uploads files. public Task<List<string>?> UploadFileAsync(IReadOnlyList<IBrowserFile> files) Parameters files IReadOnlyList<IBrowserFile> The files to upload. Returns Task<List<string>> A new task containing a list of string which represent the new path of the files uploaded."
  },
  "api/Lionk.Plugin.Blazor.PluginCard.html": {
    "href": "api/Lionk.Plugin.Blazor.PluginCard.html",
    "title": "Class PluginCard | Lionk",
    "keywords": "Class PluginCard Namespace Lionk.Plugin.Blazor Assembly Lionk.Plugin.Blazor.dll public class PluginCard : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase PluginCard Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties OnDelete Event that is triggered when the delete button is clicked. [Parameter] public EventCallback<Plugin> OnDelete { get; set; } Property Value EventCallback<Plugin> OnDependencySelect Parameter that is triggered when a dependency is selected. [Parameter] public EventCallback<Dependency> OnDependencySelect { get; set; } Property Value EventCallback<Dependency> Plugin The plugin that is displayed in the card. [Parameter] public Plugin? Plugin { get; set; } Property Value Plugin Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Plugin.Blazor.PluginUploader.html": {
    "href": "api/Lionk.Plugin.Blazor.PluginUploader.html",
    "title": "Class PluginUploader | Lionk",
    "keywords": "Class PluginUploader Namespace Lionk.Plugin.Blazor Assembly Lionk.Plugin.Blazor.dll [Route(\"/plugin-manager\")] public class PluginUploader : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase PluginUploader Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Plugin.Blazor._Imports.html": {
    "href": "api/Lionk.Plugin.Blazor._Imports.html",
    "title": "Class _Imports | Lionk",
    "keywords": "Class _Imports Namespace Lionk.Plugin.Blazor Assembly Lionk.Plugin.Blazor.dll public class _Imports : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase _Imports Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.Plugin.Blazor.html": {
    "href": "api/Lionk.Plugin.Blazor.html",
    "title": "Namespace Lionk.Plugin.Blazor | Lionk",
    "keywords": "Namespace Lionk.Plugin.Blazor Classes FileUploadService Service to upload files. PluginCard PluginUploader _Imports"
  },
  "api/Lionk.Plugin.Dependency.html": {
    "href": "api/Lionk.Plugin.Dependency.html",
    "title": "Class Dependency | Lionk",
    "keywords": "Class Dependency Namespace Lionk.Plugin Assembly Lionk.Plugin.dll Class which represents a dependency. public class Dependency Inheritance object Dependency Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the Dependency class. Constructors Dependency(bool, AssemblyName) Class which represents a dependency. public Dependency(bool isLoaded, AssemblyName assembly) Parameters isLoaded bool True if loaded false otherwise. assembly AssemblyName The assembly of the dep. Remarks Initializes a new instance of the Dependency class. Properties AssemblyName Gets the assembly of the dependency. public AssemblyName AssemblyName { get; } Property Value AssemblyName IsLoaded Gets or sets a value indicating whether if the dependency is correctly loaded. public bool IsLoaded { get; set; } Property Value bool"
  },
  "api/Lionk.Plugin.IPluginManager.html": {
    "href": "api/Lionk.Plugin.IPluginManager.html",
    "title": "Interface IPluginManager | Lionk",
    "keywords": "Interface IPluginManager Namespace Lionk.Plugin Assembly Lionk.Plugin.dll Interface which define a plugin manager. public interface IPluginManager : ITypesProvider Inherited Members ITypesProvider.NewTypesAvailable ITypesProvider.GetTypes() Methods AddPlugin(string) Adds a plugin to the manager. void AddPlugin(string path) Parameters path string The path to the plugin. DoNeedARestart() Gets a boolean indicating if a restart is needed. bool DoNeedARestart() Returns bool True if the application must be restarted false otherwise. GetAllPlugins() Gets all loaded plugins. IEnumerable<Plugin> GetAllPlugins() Returns IEnumerable<Plugin> A collection of loaded plugins. RemovePlugin(Plugin) Removes the specified plugin from the manager. As an assembly can't be removed during execution, the plugin will be disabled only after a re-run. void RemovePlugin(Plugin plugin) Parameters plugin Plugin The plugin to remove."
  },
  "api/Lionk.Plugin.Plugin.html": {
    "href": "api/Lionk.Plugin.Plugin.html",
    "title": "Class Plugin | Lionk",
    "keywords": "Class Plugin Namespace Lionk.Plugin Assembly Lionk.Plugin.dll Represents a plugin within the Lionk project, encapsulating its assembly and metadata information such as name, version, description, author, and dependencies. public class Plugin Inheritance object Plugin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Plugin(Assembly) Initializes a new instance of the Plugin class using the provided assembly. public Plugin(Assembly assembly) Parameters assembly Assembly The assembly that contains the plugin. Properties Assembly Gets the assembly associated with this plugin. public Assembly Assembly { get; } Property Value Assembly Author Gets the author of the plugin. public string Author { get; } Property Value string Dependencies Gets the dependencies of the plugin as an array of strings. public List<Dependency> Dependencies { get; } Property Value List<Dependency> Description Gets the description of the plugin. public string Description { get; } Property Value string IsLoaded Gets or sets a value indicating whether the plugin has been correctly loaded. public bool IsLoaded { get; set; } Property Value bool Name Gets the name of the plugin. public string Name { get; } Property Value string Version Gets the version of the plugin. public string Version { get; } Property Value string"
  },
  "api/Lionk.Plugin.PluginManager.html": {
    "href": "api/Lionk.Plugin.PluginManager.html",
    "title": "Class PluginManager | Lionk",
    "keywords": "Class PluginManager Namespace Lionk.Plugin Assembly Lionk.Plugin.dll Class which allows to manage plugins. public class PluginManager : IPluginManager, ITypesProvider Inheritance object PluginManager Implements IPluginManager ITypesProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PluginManager() Initializes a new instance of the PluginManager class. public PluginManager() Methods AddPlugin(string) Adds a plugin to the manager. public void AddPlugin(string path) Parameters path string The path to the plugin. DoNeedARestart() Gets a boolean indicating if a restart is needed. public bool DoNeedARestart() Returns bool True if the application must be restarted false otherwise. GetAllPlugins() Gets all loaded plugins. public IEnumerable<Plugin> GetAllPlugins() Returns IEnumerable<Plugin> A collection of loaded plugins. GetTypes() Gets all types from the provider. public IEnumerable<Type> GetTypes() Returns IEnumerable<Type> A collection of types. RemovePlugin(Plugin) Removes the specified plugin from the manager. As an assembly can't be removed during execution, the plugin will be disabled only after a re-run. public void RemovePlugin(Plugin plugin) Parameters plugin Plugin The plugin to remove. Events NewTypesAvailable Event raised when a new type is available. public event EventHandler<TypesEventArgs>? NewTypesAvailable Event Type EventHandler<TypesEventArgs>"
  },
  "api/Lionk.Plugin.html": {
    "href": "api/Lionk.Plugin.html",
    "title": "Namespace Lionk.Plugin | Lionk",
    "keywords": "Namespace Lionk.Plugin Classes Dependency Class which represents a dependency. Plugin Represents a plugin within the Lionk project, encapsulating its assembly and metadata information such as name, version, description, author, and dependencies. PluginManager Class which allows to manage plugins. Interfaces IPluginManager Interface which define a plugin manager."
  },
  "api/Lionk.TestComponent.ComponentWhichGoToError.html": {
    "href": "api/Lionk.TestComponent.ComponentWhichGoToError.html",
    "title": "Class ComponentWhichGoToError | Lionk",
    "keywords": "Class ComponentWhichGoToError Namespace Lionk.TestComponent Assembly Lionk.TestComponent.dll Counter test component. [NamedElement(\"Error component\", \"test cyclic element\")] public class ComponentWhichGoToError : BaseCyclicComponent, INotifyPropertyChanged, ICyclicComponent, IExecutableComponent, IComponent, IDisposable Inheritance object ObservableElement BaseComponent BaseExecutableComponent BaseCyclicComponent ComponentWhichGoToError Implements INotifyPropertyChanged ICyclicComponent IExecutableComponent IComponent IDisposable Inherited Members BaseCyclicComponent.CyclicComputationMethod BaseCyclicComponent.LastExecution BaseCyclicComponent.NbCycle BaseCyclicComponent.Period BaseCyclicComponent.StartedDate BaseCyclicComponent.OnTerminate() BaseExecutableComponent.IsInError BaseExecutableComponent.IsRunning BaseExecutableComponent.Abort() BaseExecutableComponent.Dispose() BaseExecutableComponent.Execute() BaseExecutableComponent.Reset() BaseComponent.Id BaseComponent.InstanceName ObservableElement.PropertyChanged ObservableElement.OnPropertyChanged(string) ObservableElement.SetField<T>(ref T, T, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CanExecute Gets a value indicating whether the component can be executed. This property must be implemented by derived classes to specify the conditions under which the component is ready to execute. public override bool CanExecute { get; } Property Value bool CounterValue Gets or sets counter value. public int CounterValue { get; set; } Property Value int Methods OnExecute(CancellationToken) Executes the component, incrementing the cycle count. This method is called during each execution cycle of the component. protected override void OnExecute(CancellationToken ct) Parameters ct CancellationToken OnInitialize() Initializes the component by setting the start date to the current date and time. This method is called automatically during the first execution of the component. protected override void OnInitialize()"
  },
  "api/Lionk.TestComponent.Counter.html": {
    "href": "api/Lionk.TestComponent.Counter.html",
    "title": "Class Counter | Lionk",
    "keywords": "Class Counter Namespace Lionk.TestComponent Assembly Lionk.TestComponent.dll Counter test component. [NamedElement(\"Counter test\", \"test cyclic element\")] public class Counter : BaseCyclicComponent, INotifyPropertyChanged, ICyclicComponent, IExecutableComponent, IComponent, IDisposable Inheritance object ObservableElement BaseComponent BaseExecutableComponent BaseCyclicComponent Counter Implements INotifyPropertyChanged ICyclicComponent IExecutableComponent IComponent IDisposable Inherited Members BaseCyclicComponent.CyclicComputationMethod BaseCyclicComponent.LastExecution BaseCyclicComponent.NbCycle BaseCyclicComponent.Period BaseCyclicComponent.StartedDate BaseExecutableComponent.IsInError BaseExecutableComponent.IsRunning BaseExecutableComponent.Dispose() BaseExecutableComponent.Execute() BaseExecutableComponent.Reset() BaseComponent.Id BaseComponent.InstanceName ObservableElement.PropertyChanged ObservableElement.OnPropertyChanged(string) ObservableElement.SetField<T>(ref T, T, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CanExecute Gets a value indicating whether the component can be executed. This property must be implemented by derived classes to specify the conditions under which the component is ready to execute. public override bool CanExecute { get; } Property Value bool CounterValue Gets or sets counter value. public int CounterValue { get; set; } Property Value int Methods Abort() Aborts the component's execution by canceling the ongoing operation. This method sets the IsInError flag to true, preventing further executions until the component is reset. Can be overridden by derived classes to implement custom abort logic. public override void Abort() OnExecute(CancellationToken) Executes the component, incrementing the cycle count. This method is called during each execution cycle of the component. protected override void OnExecute(CancellationToken ct) Parameters ct CancellationToken OnInitialize() Initializes the component by setting the start date to the current date and time. This method is called automatically during the first execution of the component. protected override void OnInitialize() OnTerminate() Terminates the execution of the component, updating the last execution time. This method is called automatically after the execution logic has completed. protected override void OnTerminate()"
  },
  "api/Lionk.TestComponent.CyclicCounter.CounterConfig.html": {
    "href": "api/Lionk.TestComponent.CyclicCounter.CounterConfig.html",
    "title": "Class CounterConfig | Lionk",
    "keywords": "Class CounterConfig Namespace Lionk.TestComponent.CyclicCounter Assembly Lionk.TestComponent.dll [ViewOf(\"Counter Configuration\", typeof(Counter), typeof(CounterConfig), ViewContext.Configuration)] public class CounterConfig : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase CounterConfig Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Component The component to configure. [Parameter] public Counter? Component { get; set; } Property Value Counter Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder"
  },
  "api/Lionk.TestComponent.CyclicCounter.CounterView.html": {
    "href": "api/Lionk.TestComponent.CyclicCounter.CounterView.html",
    "title": "Class CounterView | Lionk",
    "keywords": "Class CounterView Namespace Lionk.TestComponent.CyclicCounter Assembly Lionk.TestComponent.dll [ViewOf(\"Counter view\", typeof(Counter), typeof(CounterView), ViewContext.Widget)] public class CounterView : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender Inheritance object ComponentBase CounterView Implements IComponent IHandleEvent IHandleAfterRender Inherited Members ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Component The component to show. [Parameter] public Counter? Component { get; set; } Property Value Counter Methods BuildRenderTree(RenderTreeBuilder) Renders the component to the supplied RenderTreeBuilder. protected override void BuildRenderTree(RenderTreeBuilder __builder) Parameters __builder RenderTreeBuilder OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. protected override void OnInitialized()"
  },
  "api/Lionk.TestComponent.CyclicCounter.html": {
    "href": "api/Lionk.TestComponent.CyclicCounter.html",
    "title": "Namespace Lionk.TestComponent.CyclicCounter | Lionk",
    "keywords": "Namespace Lionk.TestComponent.CyclicCounter Classes CounterConfig CounterView"
  },
  "api/Lionk.TestComponent.html": {
    "href": "api/Lionk.TestComponent.html",
    "title": "Namespace Lionk.TestComponent | Lionk",
    "keywords": "Namespace Lionk.TestComponent Classes ComponentWhichGoToError Counter test component. Counter Counter test component."
  },
  "api/Lionk.Utils.ConfigurationUtils.html": {
    "href": "api/Lionk.Utils.ConfigurationUtils.html",
    "title": "Class ConfigurationUtils | Lionk",
    "keywords": "Class ConfigurationUtils Namespace Lionk.Utils Assembly Lionk.Utils.dll Static class that contains utility methods for save files. public static class ConfigurationUtils Inheritance object ConfigurationUtils Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AppendFile(string, string, FolderType) Appends content to a file. If the file does not exist, it will be created. public static void AppendFile(string filename, string content, FolderType folderType) Parameters filename string The filename. content string The content to append. folderType FolderType The folder type. CopyFileToFolder(string, FolderType) Method to copy a file to a folder. public static void CopyFileToFolder(string sourcePath, FolderType folderType) Parameters sourcePath string The source file path. folderType FolderType The folder type. DeleteFile(string, FolderType) Deletes a file. public static void DeleteFile(string filename, FolderType folderType) Parameters filename string The filename. folderType FolderType The folder type. FileExists(string, FolderType) Checks if a file exists. public static bool FileExists(string filename, FolderType folderType) Parameters filename string The filename. folderType FolderType The folderType. Returns bool True if it exists, false otherwise. GetFolderPath(FolderType) Gets the folder path for the specified folder type. public static string GetFolderPath(FolderType folderType) Parameters folderType FolderType The folder type. Returns string The path. ReadFile(string, FolderType) Reads content from a file. public static string ReadFile(string filename, FolderType folderType) Parameters filename string The filename. folderType FolderType The folder type. Returns string The content of the file. SaveFile(string, string, FolderType) Saves a file with the specified content. If the file already exists, it will be overwritten. public static void SaveFile(string filename, string content, FolderType folderType) Parameters filename string The filename. content string The content to save. folderType FolderType The folder type. SaveFileAsync(string, string, FolderType) Saves a file with the specified content. If the file already exists, it will be overwritten. public static Task SaveFileAsync(string filename, string content, FolderType folderType) Parameters filename string The filename. content string The content to save. folderType FolderType The folder type. Returns Task A task. TryDeleteFile(string, FolderType) Tries to delete a file. public static bool TryDeleteFile(string filename, FolderType folderType) Parameters filename string The filename. folderType FolderType The folder type. Returns bool True if the file is deleted, false otherwise."
  },
  "api/Lionk.Utils.FileHelper.html": {
    "href": "api/Lionk.Utils.FileHelper.html",
    "title": "Class FileHelper | Lionk",
    "keywords": "Class FileHelper Namespace Lionk.Utils Assembly Lionk.Utils.dll Static class that contains utility methods for files. public static class FileHelper Inheritance object FileHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateDirectoryIfNotExists(string) Method to create a directory if it does not exist. public static void CreateDirectoryIfNotExists(string path) Parameters path string The path of the directory."
  },
  "api/Lionk.Utils.FolderType.html": {
    "href": "api/Lionk.Utils.FolderType.html",
    "title": "Enum FolderType | Lionk",
    "keywords": "Enum FolderType Namespace Lionk.Utils Assembly Lionk.Utils.dll Represents the type of the configuration file. public enum FolderType Fields Config = 0 Represents the configuration folder. Data = 2 Represents the data folder. Logs = 1 Represents the log folder. Plugin = 3 Represents the plugin folder. Temp = 4 Represents the temporary folder."
  },
  "api/Lionk.Utils.html": {
    "href": "api/Lionk.Utils.html",
    "title": "Namespace Lionk.Utils | Lionk",
    "keywords": "Namespace Lionk.Utils Classes ConfigurationUtils Static class that contains utility methods for save files. FileHelper Static class that contains utility methods for files. Enums FolderType Represents the type of the configuration file."
  },
  "docs/Best-practices/README.html": {
    "href": "docs/Best-practices/README.html",
    "title": "Best Practices | Lionk",
    "keywords": "Best Practices Code Structure General All code and code documentation must be in English. Code Conventions As the application primarily uses C# and .NET technologies, follow the standard .NET best practices: .NET Convention. In brief, follow these rules: Tools and Analyzers: Enforce conventions with tools like .editorconfig and code analysis in Visual Studio. Modern Language Features: Utilize the latest C# features; avoid obsolete constructs. Exception Handling: Catch specific exceptions and use using statements for resource management. Type Usage: Prefer language keywords (e.g., string over System.String). String Handling: Use string interpolation for concatenation and StringBuilder for large text manipulations. LINQ Queries: Use meaningful names, implicit typing, and align query clauses for readability. Delegates: Use Func<> and Action<> for delegates and lambda expressions for event handlers. Variable Declarations: Use var only when the type is obvious. Style Guidelines: Use four spaces for indentation, align code consistently, and follow the \"Allman\" style for braces. Comment Style: Use single-line comments for brief explanations and XML comments for methods and classes. Identifier Names Identifiers must be clear, concise, and meaningful. Follow these rules: Naming Rules. In brief, follow these rules: Starting Characters: Methods start with a capital letter and a verb (e.g., GetName, Execute). Properties start with a capital letter. Private fields start with an underscore (e.g., _name). Local variables start with a lowercase letter. Valid Characters: Can include Unicode letters, digits, connecting characters, combining characters, or formatting characters. Interfaces: Prefix with I. Attributes: Suffix with Attribute. Enums: Singular for non-flags, plural for flags. Clarity: Prefer meaningful, descriptive names over abbreviations. Tools to apply these rules: StyleCop: Analyzes C# source code to enforce style and consistency rules. EditorConfig: Defines coding styles and formatting rules for Visual Studio. Refer to: Apply StyleCop. Code Documentation All code must be documented using XML comments. Write clear and concise XML comments in English for all public methods and classes. OOP and SOLID Principles Write code following OOP and SOLID principles. Ensure code is modular, readable, extendable, and maintainable. Use interfaces and abstract classes to enhance modularity and testability. Unit Tests All code must be tested using unit tests written with the xUnit framework. Write clear and concise unit tests in English for all public methods and classes. Ensure tests are understandable and maintainable."
  },
  "docs/Best-practices/applyStylecop.html": {
    "href": "docs/Best-practices/applyStylecop.html",
    "title": "Stylecop and editor config installation | Lionk",
    "keywords": "Stylecop and editor config installation The following steps will guide you through the installation of Stylecop and editor config in Visual Studio. This will help you to enforce coding standards and conventions in your C# projects. Installation To use Stylecop and editor config in Visual Studio, you only need to copy the configuration files to your project. All the files must be placed near you .sln file. Three files are required: .editorconfig - used to define coding styles and formatting rules for Visual Studio. stylecop.json - used to define the rules for Stylecop. Directory.Build.props - used to set some information for the build process and to include the Stylecop analyzers. These files can be found in this folder. Copy them to your project folder near the .sln file and that's all."
  },
  "docs/Mockup/README.html": {
    "href": "docs/Mockup/README.html",
    "title": "Lionk Application Mockup | Lionk",
    "keywords": "Lionk Application Mockup 0. Introduction This document describes the mockup of Lionk application. The mockup is a visual representation of the application's user interface. It is used to give an idea of what the application will look like and how it will function. The mockup is not a final design, but rather a starting point for further development. 1. Dashboard Just after logging in, the user arrives on the application's homepage. This page features a left sidebar navigation menu that allows the user to navigate between different sections of the application. The homepage also displays a dashboard with information about imported plugins. The right part is a window that displays the different pages of the application. We are currently on the Dashboard page. This page shows all the plugins imported by the user. There are currently none. By clicking the Add Plugin Button in the center of the window, the user can import a plugin. 2. Add Plugin After clicking the Add Plugin Button, a modal window opens. This window allows the user to import a plugin from the plugins listed in the system. The user names the plugin to import and clicks Add. 3. Plugin Specific Configuration Page Now that the user has imported a plugin, they can configure the specific settings of the plugin. To do this, they click on the imported plugin. A new page opens, displaying the specific settings of the plugin. Here is a fictitious example of Clock.dll, a plugin that allows displaying a clock on the application. Its configuration allows setting the time format and choosing whether to hide the date. 4. Dashboard with Clock Plugin Here is our new Dashboard, with the Clock.dll plugin imported and configured. The clock is displayed at the top left of the page. Now let's add another plugin. 5. Rpi Plugin As our application is hosted on a Raspberry Pi, we have developed a plugin to access the GPIO of the Raspberry Pi and read DS18B20 type temperature sensors, which we named RPItemp. We will now configure the sensors to read. We have added two sensors, the 28-00000a3b1b12 sensor which we named Chimney and the 28-00000a3b1b3d sensor which we named Hot water. We can now see the values of these sensors on our Dashboard. Let's now configure the notifications. 6. Notification Configuration We have selected Notification in the left sidebar navigation menu. On this page, we see two lists. One listing the plugins that can create notifications, and the other listing the plugins used as channels to send notifications. In our case, we have enabled notifications for the Chimney sensor via the Discord channel. But we also want to receive emails. We will add a plugin for this. By pressing the + button next to the channels, a modal window opens with a list of the system's channels. We will select Mail and give it a name. We now have a new Mail channel that we will configure. If the email channel is enabled on the notification page, messages from Chimney will also be sent by email. 7. Conclusion This document gives an overview of the application's functionality and shows that the developer can create a plugin and easily add it to the application."
  },
  "docs/RaspberryDeploy.html": {
    "href": "docs/RaspberryDeploy.html",
    "title": "How to deploy LionkApp on Raspberry Pi | Lionk",
    "keywords": "How to deploy LionkApp on Raspberry Pi This part explains how to deploy LionkApp on a Raspberry Pi using docker and docker-compose. 1. Install docker If Docker is not installed on your Raspberry Pi, you can install it by following the instructions below. sudo apt-get update sudo apt-get install docker sudo apt-get install docker-compose 2. Install ufw It is recommended to install ufw (Uncomplicated Firewall) to define the firewall rules for your Raspberry Pi and set the rules for the ports that you want to use on LionkApp. sudo apt-get install ufw 3. Configure ufw Now you need to configure the ufw to allow the ports that you want to use on LionkApp. You can use the following commands to allow the ports. Please keep in mind that you need to allow the port that you will use for LionkApp and SSH. sudo ufw allow 22 sudo ufw allow <LionkAppPort> sudo ufw enable 4. Create a docker-compose.yml file Create a docker-compose.yml file in the directory that you want to deploy LionkApp. You can use the following template for the docker-compose.yml file. version: '3.8' services: lionkapp: image: ghcr.io/lionk-framework/lionkapp:latest privileged: true devices: - \"/dev/gpiomem:/dev/gpiomem\" - \"/dev/mem:/dev/mem\" - \"/dev/ttyAMA0:/dev/ttyAMA0\" - \"/dev/ttyS0:/dev/ttyS0\" volumes: - ./sys/class/gpio:/sys/class/gpio - ./config:/app/config - ./plugins:/app/plugins - ./data:/app/data - ./logs:/app/logs - ./temp:/app/temp - ./keys:/root/.aspnet/DataProtection-Keys ports: - \"5001:5001\" 4.1. Explanation of the docker-compose.yml file image: The image that will be used to deploy LionkApp. You can use the latest version of the image by using ghcr.io/lionk-framework/lionkapp:latest. privileged: This is required to access the GPIO pins on the Raspberry Pi. devices: The devices that will be used by the LionkApp to access the GPIO pins. volumes: The volumes that will be used by the LionkApp to store the configuration, plugins, data, logs, temp files, and keys. Keys are used for the authentication protection, if you don't store the keys, you will need to re-authenticate every time you restart the LionkApp by clearing the cookies. Sys folder is used to access the GPIO pins. The settings folder is used to store the configuration file. ports: The port that will be used by the LionkApp. You can change the port by changing the first port number in the port mapping. 4.2. Changing the ports settings 4.2.1. Changing the container port You can change the port that will be used by docker to expose LionkApp by changing the first port number in the port mapping. For example, if you want to use port 8080 instead of 5001, you can change the port mapping as below. ports: - \"8080:5001\" 5. Deploy LionkApp Now you can deploy LionkApp by using the following command inside the directory that contains the docker-compose.yml file. docker-compose up if you want to run the container in the background, you can use the following command. docker-compose up -d 6. Access LionkApp If you have configured the ports and the firewall correctly, you can access LionkApp by using the following URL in your browser. http://<RaspberryPiIP>:<LionkAppPort> 7. Stop or restart LionkApp You can stop or restart LionkApp by using the following commands. docker-compose stop docker-compose up 8. Update LionkApp To update LionkApp, you can use the following commands. docker-compose down # if the container is running docker-compose pull # to pull the latest image docker-compose up 9. Attaching a terminal to the container If you want to attach a terminal to the container, you can use the following command. first list the running containers. docker container ps the output will be like below. CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f72fef8584b0 ghcr.io/lionk-framework/lionkapp:latest \"./LionkApp\" 29 minutes ago Up 21 seconds 0.0.0.0:5001->5001/tcp, :::5001->5001/tcp pi_lionkapp_1 then you can use the the CONTEINER ID to attach a terminal to the container with the following command. docker attach <CONTAINER ID> 10. Attach an interactive terminal to the container If you want to attach an interactive terminal to the container, you can use the following command. docker exec -it <CONTAINER ID> /bin/bash 11. Access the docker logs You can access the docker logs of the container by using the following command. These logs represent the logs if docker and the application (Like Console.WriteLine() etc.). docker logs <CONTAINER ID>"
  },
  "docs/Workflow/README.html": {
    "href": "docs/Workflow/README.html",
    "title": "Development and Deployment Workflow | Lionk",
    "keywords": "Development and Deployment Workflow 0. Workflow Diagram . The workflow is divided into 3 main branches: main, dev, and feature branches. The main branch is the production branch, the dev branch is the development branch, and the feature branches are the branches where the features are developed. Anybody can create new feature branches from the dev branch. When the feature is ready, a pull request is created from the feature branch to the dev branch. The CI/CD pipeline will run tests and build the project. If the tests are passed, the PR will be merged to the dev branch after reviews. Once the dev branch is ready to be released, a pull request is created from the dev branch to the main branch. The CI/CD pipeline will run tests and build the project. If the tests are passed, the PR will be merged to the main branch after reviews. Once the PR is merged, the CI/CD pipeline will deploy the release. The artifacts deployed depend on the modifications made in the PR. The version is automatically updated by the CI/CD pipeline. The .csproj file is updated with the new version number, changelog, and description. The PR title and body must be specific to the type of modification made. If the PR title or body is not correct, the PR will just be closed and re-opened. If the tests are not passed, the PR must be corrected and pushed again until the tests are passed. When the PR is finally merged into main, new NuGet package versions are created and published to the NuGet repository if needed. If the base app is modified, a new docker image is created and published to the Docker Hub repository. If the documentation is modified, the documentation is updated and published to the GitHub Pages repository. If the workflow is modified, the workflow is updated and published to the GitHub repository. 1. Workflow Steps 1.1. Create your branch When a new feature or bug fix needs to be developed, create a new branch from the dev branch. 1.2. Make your changes and merge it to dev branch Make your changes and push them to your branch. Create a pull request from your branch to the dev branch. The CI/CD pipeline will run tests and build the project. If the tests are passed, the PR will be merged to the dev branch after reviews. 1.3. Deploy release and Create a Pull Request with specific Pull Request name and body into main Once develop branch is ready to be released, create a pull request from dev to main branch. For each type of modification, like app, nuget, doc ,wof , use specific Pull Request names and bodies. <version type> will be patch, minor, or major For code changes: The version is automatically updated by the CI/CD pipeline. The .csproj file is updated with the new version number, changlog and description. Keep in mind that the pull request workflow creates a commit of .csproj files. Even if it fails, the commit is overwritten by another commit. In any case, you must pull the latest modifications before making a new commit, until the tests have been passed. 1.3.1. If you want to merge application features or bug fixes PR name: app: <version type> PR body: - feature or bug fix 1 - feature or bug fix 2 - feature or bug fix 3 example: PR name: app: patch PR body: - fix mainwindows bug - fix dependency injection bug 1.3.2. If you want to merge nuget library features or bug fixes PR name: nuget: project1 <version type>, project2 <version type>, project3 <version type>, ... PR body: project1 - feature or bug fix 1 - feature or bug fix 2 project2 - feature or bug fix 1 project3 - feature or bug fix 1 - feature or bug fix 2 - feature or bug fix 3 example: PR name: nuget: Logger patch, Authentification minor, Core major PR body: Logger - fix write file bug Authentification - fix login bug - Add pink logout button because it's cool Core - Change the way to get the user - Replace API Urls 1.3.3. If you want to merge documentation To merge documentation, it is important that the code is not modified, which is why tests are performed on file extensions. By default, a list of extensions is defined as documentation. If you want to add other extensions, you need to list them in the body in this way: - docx - xlsx (no dot) Default extensions that do not need to be entered in the PR body: - md - txt - drawio - png - jpg - jpeg - gif - svg PR name: doc: <Name or text> [optional] PR body: - <authored file extension> - <authored file extension> - <authored file extension> 1.3.4. If you want to merge workflow to merge a workflow, the procedure is similar to the documentation merge procedure, with the exception of the default file extensions Default extensions that do not need to be entered in the PR body: - yml - py - sh PR name: wof: <Name or text> [optional] PR body: - <authored file extension> - <authored file extension> - <authored file extension> 1.4. Check failed If the check fails, look at the error message in the action tab https://github.com/Lionk-Framework/Lionk/actions Then, if the check fails because the PR title or body is not correct, the PR will just be closed and re-opened. You don't need to create a new PR. If the check fails because the tests are not passed, you must correct the code and push again until the check passes. 2. Workflow runnner if you want to use your own runner, you need to modify the GitHub action variable named RUNNER_DISTRIBUTION. To use your own runner: self-hosted. To use Github runners: ubunutu-latest 2.1 Self-hosted runner When using a self-hosted runner, pull-requests from external contributors should never be validated, as they may result in malicious code or secret leaks. To guarantee security, I suggest using docker-based runners to compartmentalize the application and, above all, shut it down once it's no longer needed. To get a token for a self-hosted runner, you need to folow this instructions: Go here: https://github.com/organizations/Lionk-Framework/settings/actions/runners Click on the button Add runner Look at the configuration section Copy the token that is displayed after --token here a docker-compose file to run a self-hosted runner: version: '2.3' services: runner: image: myoung34/github-runner:latest environment: REPO_URL: https://github.com/votre-utilisateur/votre-repo RUNNER_NAME: <runner name> RUNNER_TOKEN: <the token you copied> RUNNER_WORKDIR: /tmp/github-runner RUNNER_LABELS: <custom labels> volumes: - ./runner:/tmp/github-runner - /var/run/docker.sock:/var/run/docker.sock restart: always example: version: '2.3' services: runner: image: myoung34/github-runner:latest environment: REPO_URL: https://github.com/Lionk-Framework/Lionk RUNNER_NAME: Alex-lionk-runner RUNNER_TOKEN: <the token you copied> RUNNER_LABELS: linux,x64,ubuntu volumes: - ./runner:/tmp/github-runner - /var/run/docker.sock:/var/run/docker.sock restart: always 2.2 Workflow parallelization If your workflow has parallel tasks, you can set up self-hosted runners in a simple way, by adding many other services to the docker-compose file. You need to change the folder name of the volumes to ./runner1, ./runner2, ./runner3, ... and change the RUNNER_NAME. The token can be the same for all runners. version: '2.3' services: runner1: image: myoung34/github-runner:latest environment: REPO_URL: https://github.com/Lionk-Framework/Lionk RUNNER_NAME: Alex-lionk-runner-1 RUNNER_TOKEN: <the token you copied> RUNNER_LABELS: linux,x64,ubuntu volumes: - ./runner1:/tmp/github-runner - /var/run/docker.sock:/var/run/docker.sock restart: always runner2: image: myoung34/github-runner:latest environment: REPO_URL: https://github.com/Lionk-Framework/Lionk RUNNER_NAME: Alex-lionk-runner-2 RUNNER_TOKEN: <the token you copied> RUNNER_LABELS: linux,x64,ubuntu volumes: - ./runner2:/tmp/github-runner - /var/run/docker.sock:/var/run/docker.sock restart: always"
  },
  "docs/architectureDescription.html": {
    "href": "docs/architectureDescription.html",
    "title": "Project Architecture Description | Lionk",
    "keywords": "Project Architecture Description Overview Li/onk Core is designed as a modular platform enabling the management and integration of various components through plugins. The architecture leverages .NET, allowing for a flexible, extensible system with components that can be independently developed, deployed, and managed. Architecture Components 1. Core Application The core application serves as the foundational platform for Li/onk Core. It is responsible for the overall management, coordination, and integration of the various plugins and components. Published as: Docker Image Responsibilities: Loading and managing plugins Providing the main user interface for configuration and monitoring Ensuring communication between different plugins and components Handling security and user management 2. Framework The framework provides the necessary tools and interfaces for plugin development and integration. It ensures that all plugins adhere to a common standard, facilitating interoperability and seamless integration. Published as: NuGet Packages Responsibilities: Defining standardized interfaces for plugin development Providing base classes and utilities for common functionalities Ensuring communication protocols between the core application and plugins Offering tools for logging, monitoring, and security management 3. Plugins Plugins are independently developed components that extend the functionality of the core application. Each plugin represents specific functionalities, such as managing sensors, actuators, or other system components. Published as: .dll (Dynamic Link Libraries) Responsibilities: Implementing specific component functionalities (e.g., sensor data collection, actuator control) Providing user interface elements for their configuration and control Integrating with the core application through the framework‚Äôs interfaces Interaction and Integration Core Application and Framework The core application relies on the framework to provide the foundational services and interfaces required for plugin management. When the core application starts, it initializes the framework, which in turn handles the discovery and loading of plugins. Core Application: Initializes the framework on startup Manage all the frontend views and user interactions Uses the framework to discover available plugins Manages the lifecycle of plugins (loading, executing, unloading) Framework: Provides interfaces for plugin discovery and management Offers utilities and base classes for plugin development Ensures secure and standardized communication between core and plugins Plugins and Framework Plugins are developed using the framework‚Äôs tools and interfaces, ensuring they comply with the system‚Äôs standards. When deployed, plugins are discovered and managed by the core application through the framework. Plugins: Implement functionalities using the framework‚Äôs interfaces Provide user interface elements for the core application to render Interact with other plugins and the core application through standardized protocols Framework: Facilitates the registration and discovery of plugins Ensures secure and efficient communication between plugins and the core application Provides common utilities and services used by plugins (e.g., logging, security) Deployment and Distribution Docker Image The core application is distributed as a Docker image, ensuring a consistent and reproducible deployment environment. This image includes the core application and the framework, ready to manage and integrate plugins. Deployment: Pull the Docker image from the registry Run the Docker container on the target environment (supports both ARM and x86 architectures) The container initializes the core application, which in turn uses the framework to manage plugins NuGet Packages The framework is distributed as a set of NuGet packages, providing developers with the necessary tools and interfaces for plugin development. Distribution: NuGet packages are published to a NuGet repository Developers add the NuGet packages to their projects to create compatible plugins Ensures versioning and dependency management for plugin developers .dll Plugins Plugins are distributed as .dll files, allowing for easy deployment and integration with the core application. Distribution: Plugins are developed using the framework‚Äôs NuGet packages Compiled plugins are packaged as .dll files Plugins are deployed by placing the .dll files in a designated directory where the core application can discover and load them Visual Representation Key Points The Core Application runs inside a Docker container, ensuring consistent deployment. The Framework is provided as NuGet packages, used by both the core application and plugins. Plugins are developed independently and deployed as .dll files, allowing for easy integration and extension of the core functionality. This architecture ensures that Li/onk Core is flexible, extensible, and easy to manage, supporting a wide range of components and use cases in home and industrial environments."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | Lionk",
    "keywords": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | Lionk",
    "keywords": "Introduction"
  },
  "docs/processDevelopment.html": {
    "href": "docs/processDevelopment.html",
    "title": "General Process | Lionk",
    "keywords": "General Process 1. Initial Planning Phase Defining Objectives and Initial Architecture: Establish clear project objectives and an initial system architecture for Li/onk Core, considering the integration of various components such as sensors, displays, and other smart home devices. Creating the Product Backlog: Compile all necessary features, tasks, and improvements into a product backlog. Use user stories to describe features from the end-users' perspective. 2. Iterative Development with SCRUM Sprints: Divide the development process into 1- to 2-week sprints. Each sprint begins with a planning meeting where the team selects tasks from the backlog to complete during the sprint. As an example, the first sprint is planned using github project, issues and Kanban. It's available here : Project Continuous Development and Testing: Apply pair programming and continuous integration to maintain code quality and respond quickly to changes. Encourage test-first programming to ensure each feature is properly tested before integration. Sprint Review and Retrospective: At the end of each sprint, hold a sprint review with stakeholders to demonstrate developed features and receive direct feedback. Follow this with a sprint retrospective to identify process improvements. 3. Validation and Continuous Delivery Regular Deployments: Ensure regular deployments of functional software versions for continuous evaluation by end users, adjusting the product based on feedback and changing requirements. Data-Driven Improvements: Use collected data (e.g., statistics on dangerous situations) to continuously improve the product. Automatic workflow: Implement automatic testing and deployment workflows to streamline the development process and ensure consistent quality. Feedback Loop: Establish a feedback using channels such as github issues. 4. Adaptation and Scalability Continuous Evaluation: Integrate regular checkpoints to assess if the project aligns with long-term goals and user needs. Flexibility: Be prepared to adapt development plans and product features in response to technological changes and user feedback. 5. First plugin developement - **Plugin Development**: Create a simple plugin to demonstrate the process and provide a foundation for future plugin development."
  },
  "docs/projectDescription.html": {
    "href": "docs/projectDescription.html",
    "title": ".NET Plugin Architecture Project Description | Lionk",
    "keywords": ".NET Plugin Architecture Project Description 1. Problem Statement üëÄ Problem Managing a diverse set of home and industrial components in an integrated and efficient manner is challenging. Existing solutions often lack flexibility, requiring significant customization and redevelopment when integrating new components. This inflexibility can lead to increased costs and reduced system efficiency. Additionally, many existing systems are not designed to handle real-time data exchange and monitoring efficiently, leading to delays and potential errors in critical operations. There is also a need for a secure, user-friendly interface that allows administrators and operators to supervise and control the system easily. üí≠ Proposition We propose developing Li/onk Core, a modular, plugin-based platform in .NET, to address these challenges. Our solution will provide: Real-Time Data Handling: Utilizing SignalR for efficient, real-time communication between components and the user interface. Extensibility: A robust plugin architecture allowing easy addition of new components without needing to recompile the core application. User-Friendly Interface: A web-based interface using Blazor Server, providing a seamless user experience for both administrators and operators. Cross-Architecture Support: The application will be compiled to run on both ARM and x86 architectures with a docker image, ensuring wide compatibility and deployment flexibility. This approach will reduce integration time and costs, improve system efficiency, and provide a scalable and secure solution for managing diverse components in home and industrial environments. 2. Objective The project aims to create a modular architecture in the form of plugins in .NET, allowing the connection of various installation components to form an integrated system. 2.1. Project Components 2.1.1. System Base Core Framework: Provides the basic functionalities and necessary interfaces for loading and managing plugins. Plugin Management: Mechanism for discovering, loading, and executing plugins. 2.1.2. Plugins Installation Components: Each plugin represents a specific component or several components of an installation (e.g., sensors, clocks, actuators, alarms, etc.). Standardized Interfaces: Define common interfaces to ensure interoperability between plugins. 2.1.3. Connectivity and Communication Component Utilization: Use the communication protocol of the component directly within the plugin (e.g., HomeMatic IP via Python lib, DS18B20 sensors via GPIO, etc.). 2.1.4. Supervision and Control User Interface (UI): Provide an interface for system supervision and control. May include graphical visualizations, dashboards, and diagnostic tools. Each plugin will implement its own user interface that will be represented in the main interface. Logs and Monitoring: Logging and monitoring system to track system performance and potential errors, with a monitoring interface available for plugin implementation. 2.1.5. Security Authentication and Authorization: Mechanisms to control access to different components and system functionalities. Roles: Definition of roles for users and plugins. Key Features Modularity: Add and remove components without interrupting the system operation. Extensibility: Ease of adding new plugins to integrate new types of components. Interoperability: Ensure communication and cooperation between different components. Security: Implement security mechanisms to protect exchanged data and system access. Technologies Used .NET Core/8+: To ensure performance, reliability, and portability. C#: Main language for plugin and core framework development. Entity Framework Core: For data management if necessary. ASP.NET Core: For creating the web user interface. SignalR: For real-time communication between components and the user interface. refers to : Technical Specification Use Cases Industry 4.0: Integration of sensors, machines, and management systems for a connected factory. Home Automation: Connecting smart home devices to create an automated house. Energy: Management and supervision of energy production and distribution installations. This project will enable users to design flexible and robust systems by combining various components through a .NET plugin architecture, promoting innovation and efficiency in various industrial and private sectors. 3. Functional and Non-Functional Requirements this chapter is based on the user stories available here : User Stories 3.1 Functional Requirements User: Operator Data Consultation via Dashboard Users should be able to continuously view component-specific data via a real-time updated dashboard. Alarm Management Users should be notified in case of system or component failure. Users should be notified when notifications are raised by components, for example, if a room's temperature exceeds a certain threshold. Remote Access The application should be accessible remotely via a web browser. User: Administrator Inherits all operator needs. Application Configuration The system should allow the addition and removal of components. Plugin Integration Administrators should be able to integrate third-party plugins into the application. Administrators should be able to enable or disable plugins. Component management Administrators should be able to configure the behavior of components. Administrators should be able to view the status of components. Administrators should be able to configure alarms and notifications for components. Administrators should be able to configure the data collection frequency for components. Administrators should be able to add or delete components. User Management Administrators should be able to add or remove users. Administrators should be able to assign roles to users. Data Management The system should allow exporting collected data in JSON format with a user-defined filename. The system should allow deleting data collected by a component. User: Developer Plugin Development Developers should have access to complete documentation and code examples to create new plugins compatible with the system. Developers should be able to access the SDK to develop plugins via NuGet packages. Plugin Deployment Developers should be able to submit their plugins to the administrator for integration into the system as dll. 3.2 Non-Functional Requirements Modularity, Extensibility, and Maintenance The system should be designed to facilitate the addition of new components and plugins without requiring major modifications to the existing architecture. The system should be designed modularly to facilitate maintenance and updates. Performance The dashboard should update continuously with a maximum latency of 2 seconds. Alarm notifications should be sent within a maximum of 5 seconds after an event is detected. Security The application should ensure secure management of users and roles. Data should be protected and secured, especially during the transmission of notifications and remote access. Sensitive data should be protected. Easy Deployment The application should be published as a Docker image to facilitate deployment and administration. New versions of the application and plugins should be easily deployable via Docker and NuGet. Compatibility and Portability The application should be compatible with major operating systems and cloud environments via Docker. The system should be compatible with common web browsers (Chrome, Firefox, Edge, Safari). Plugins should be portable and compatible with different versions of the application. Documentation and Developer Support Documentation for plugin development should be clear, concise, and accessible. The SDK should be well-documented and regularly updated to facilitate the development of new plugins. Reliability The system should be reliable, with minimal downtime, and capable of handling failures without data loss. Scalability The system should be able to handle data and notifications from up to 100 components simultaneously without performance degradation. Usability The user interface should be intuitive and easy to use, with a minimal learning curve."
  },
  "docs/technicalSpecification.html": {
    "href": "docs/technicalSpecification.html",
    "title": "Technical Specification | Lionk",
    "keywords": "Technical Specification Li/onk Core Li/onk Core is a modular platform developed in .NET designed to enable the management and integration of various components through plugins. The project is crafted to cater to end users (operators and administrators) as well as plugin developers, offering maximum flexibility and extensibility. The primary goal is to enhance the quality of life in home environments by allowing seamless integration and management of various components. FrontEnd Framework and Language The frontend will be built using Blazor Server with .NET and C#. Blazor Server enables the development of interactive web applications using C#, which offers several advantages: Unified Development: Allows the use of C# for both client-side and server-side logic, leveraging the team's expertise. Real-Time Updates: Blazor Server facilitates real-time web functionality, making it ideal for interactive user interfaces. Strong Typing and Compilation: Ensures better error checking during development, leading to more reliable applications. Challenges include ensuring optimal performance for high-frequency updates and the necessity for developers to adapt to Blazor-specific paradigms if they are more familiar with other web technologies. BackEnd Programming Language The backend will utilize C#, a powerful and versatile language that integrates seamlessly with the .NET ecosystem, providing a consistent development experience across the entire application. Framework The backend will be constructed using ASP.NET Core, employing the following modules: EF Core: For database management, providing a robust ORM (Object-Relational Mapping) solution. Newtonsot.Json: For JSON serialization and deserialization, enabling efficient data storage for persistent data without using any db. Influx DB For measure logging, providing a robust time serie db optimized for time-stamped or time series data. SignalR: For asynchronous, real-time communication, enabling live updates and notifications. Plugin Architecture Li/onk Core features a plugin architecture to extend functionality without requiring recompilation of the core application. Key components include: NuGet Packages: The core framework and tools for plugin development will be distributed via NuGet packages. This approach simplifies version control and dependency management. Modular Design: Encourages the development, testing, and maintenance of independent components, allowing for flexible and scalable application growth. Advantages of Plugin Architecture Flexibility: Easily add or remove features without modifying the core application. Scalability: Supports the independent development of components, which can be integrated as needed. Community and Extensibility: Allows external developers to contribute plugins, fostering a rich ecosystem of shared solutions. Deployment The application will be distributed as a Docker image, providing a consistent and reproducible environment for deployment. This choice is driven by several factors: Simplified Deployment: Docker images ensure that the application runs consistently across various environments. Isolation and Security: Containers provide a secure environment, isolating the application from potential conflicts. Scalability: Docker facilitates the easy scaling of the application by running multiple container instances as required. On-Premise Deployment Li/onk Core is designed for on-premise deployment, meaning it will run directly on the client's infrastructure. This approach offers: Data Privacy: Ensures that sensitive data remains within the client's control. Customization: Clients can tailor the application to meet their specific needs and operational environments. Performance: Local deployment reduces latency, improving the overall performance and responsiveness of the application. Resources and Learning Below are some resources to help with learning Blazor, ASP.NET Core, and Docker, as well as resources for plugin development: Blazor Documentation ASP.NET Core Documentation NuGet Package Creation Docker Documentation With these choices, Li/onk Core aims to provide a flexible, extensible, and user-friendly platform for managing home environment components, ensuring ease of use for both end users and developers."
  },
  "docs/unitTests.html": {
    "href": "docs/unitTests.html",
    "title": "LionkTest Documentation | Lionk",
    "keywords": "LionkTest Documentation Overview This documentation is for the LionkTest project, which is intended to test the Lionk project, plugins and libraries. Currently, all tests are contained within a single file, Tests.cs. As our knowledge and requirements grow, we plan to separate tests into individual files. Tests.cs Content The Tests.cs file contains the following code: // Copyright ¬© 2024 Lionk Project namespace LionkTest; /// <summary> /// This class will be used for testing the Lionk project. /// </summary> public class Tests { /// <summary> /// This method is called immediately before each test is run. /// </summary> [SetUp] public void Setup() { } /// <summary> /// First Test of Lionk Project. /// </summary> [Test] public void FirstTest() { bool test = true; Assert.IsTrue(test); } } Adding More Tests To add more tests to the Tests.cs file, follow the example below: Example: Adding a Second Test To add a second test, create a new method in the Tests class and annotate it with [Test]. /// <summary> /// Second Test of Lionk Project. /// </summary> [Test] public void SecondTest() { int expectedValue = 5; int actualValue = 2 + 3; Assert.AreEqual(expectedValue, actualValue); } Example: Adding a Test with Setup If you need to initialize some data before running a test, use the Setup() method. private int _value; /// <summary> /// This method is called immediately before each test is run. /// </summary> [SetUp] public void Setup() { _value = 10; } /// <summary> /// Test that uses the setup value. /// </summary> [Test] public void TestWithSetup() { int expectedValue = 10; Assert.AreEqual(expectedValue, _value); } Future Plans Currently, all tests are contained in Tests.cs. As we gain more experience and the number of tests grows, we plan to organize tests into separate files for better maintainability and clarity. For example: LoginTests.cs for login-related tests DatabaseTests.cs for database-related tests UITests.cs for user interface tests Conclusion This document provides an overview of the current test structure for the LionkTest project and examples for adding new tests. By following these guidelines, we can ensure that our tests are organized and scalable."
  },
  "docs/userstories.html": {
    "href": "docs/userstories.html",
    "title": "User Stories for the .NET Plugin Architecture Project | Lionk",
    "keywords": "User Stories for the .NET Plugin Architecture Project User: End User (Operator) User Story 1: Data Consultation As an end user, I want to be able to view data specific to the component used from a continuously updated dashboard. User Story 2: Alarm Management As an end user, I want: to be notified when there is a system failure or a component failure. to be notified when a notification is raised within one of the components, for example, if the component allows me to be notified when the temperature of a room exceeds a certain threshold. all these notifications/alarms to be displayed regardless of the page used. to be notified by email/push notification. User Story 3: Application Access As an end user, I want to be able to access the application remotely via a web browser. User: End User (Administrator) inherits all operator needs User Story 4: Application Configuration As an end user, I want: to be able to configure the application according to my needs, by adding or removing components. to be able to configure components according to the parameters they offer. to be able to link components together. User Story 5: Plugin Integration As an end user, I want: to be able to integrate third-party plugins into the application. to be able to enable/disable plugins. User Story 5: Component management As an end user, I want: to be able to configure the behavior of components. to be able to view the status of components. to be able to configure alarms and notifications for components. to be able to configure the data collection frequency for components. to be able to add or delete components. User Story 6: User Management As an end user, I want: to be able to add/remove users. to be able to assign roles to these users. User Story 7: Data Management As an end user, I want: to be able to export data collected by a component by choosing the output file name in JSON format. to be able to delete data collected by a component. User: Plugin Developer User Story 8: Plugin Development As a plugin developer, I want: to access complete documentation and code examples to create new plugins compatible with the system. to be able to access the SDK to develop plugins via NuGet packages. User Story 9: Plugin Deployment As a plugin developer, I want: to be able to submit my plugins to the administrator for integration into the system as dll. User Stories for the Plugin PoC for Component Integration for Boiler Control User: End User (Operator) User Story 1: As an end user, I want: to be able to retrieve the energy produced by an accumulation fireplace and store it. the heat flow to be optimized based on storage temperatures via a three-way valve. the system to be able to self-regulate based on the temperatures of the living room fireplace. to receive a notification if the system fails. to receive an alarm if the storage temperature exceeds a certain threshold. to receive an alarm if the temperature of the living room fireplace exceeds a certain threshold. to know the amount of energy stored to determine if it is appropriate to light the living room fireplace."
  },
  "index.html": {
    "href": "index.html",
    "title": "Li/onk Core | Lionk",
    "keywords": "Li/onk Core ‚ó¶ Connecting Components Seamlessly! Lionk Li/onk Core is a modular platform developed in .NET designed to enable the management and integration of various components through plugins. The project is crafted to cater to end users (operators and administrators) as well as plugin developers, offering maximum flexibility and extensibility. The primary goal is to enhance the quality of life in home environments by allowing seamless integration and management of various components. This page is the official development documentation for the Li/onk Core project."
  },
  "src/App/LionkApp/README.html": {
    "href": "src/App/LionkApp/README.html",
    "title": "Lionk App | Lionk",
    "keywords": "Lionk App This is the Lionk App README file."
  },
  "src/Lib/Lionk.Auth.Razor/README.html": {
    "href": "src/Lib/Lionk.Auth.Razor/README.html",
    "title": "Lionk User Authentication Library for Blazor Server | Lionk",
    "keywords": "Lionk User Authentication Library for Blazor Server Overview The Lionk User Authentication Library provides a robust and flexible authentication solution for Blazor Server applications. This library allows developers to manage user authentication, handle roles, and persist user data securely within the browser. With easy-to-use components and services, it integrates seamlessly into Blazor applications, supporting both basic authentication and role-based access control. Features User Management: Create, update, retrieve, and delete users using UserService. Role-Based Access Control: Display content conditionally based on user roles using Blazor's AuthorizeView component. Persistent Authentication State: Maintain user sessions across page reloads or browser restarts using local storage with UserServiceRazor. Secure Data Handling: Use hashing and salting techniques for password security. Extensible: Easily extend or replace storage mechanisms for user data persistence. Installation To use this library, add the following NuGet packages to your Blazor Server project: dotnet add package Lionk.Auth dotnet add package Lionk.Auth.Razor Getting Started 1. Setting Up the Services Register the necessary services in your Startup.cs or Program.cs file to integrate the authentication library: using Lionk.Auth.Abstraction; using Lionk.Auth.Identity; public void ConfigureServices(IServiceCollection services) { services.AddRazorComponents().AddInteractiveServerComponents(); services.AddMudServices(); // Register the authentication services services.AddScoped<UserService>(); services.AddScoped<UserServiceRazor>(); services.AddSingleton<IUserRepository, UserFileHandler>(); services.AddSingleton<IUserService>(sp => new UserService(sp.GetRequiredService<IUserRepository>())); services.AddScoped<UserAuthenticationStateProvider>(); services.AddScoped<AuthenticationStateProvider>(sp => sp.GetRequiredService<UserAuthenticationStateProvider>()); } 2. Creating a User To create a user, instantiate the User class with the necessary properties, including roles, and then use the UserService to insert the user: using Lionk.Auth.Identity; using Lionk.Auth.Utils; var salt = PasswordUtils.GenerateSalt(32); var passwordHash = PasswordUtils.HashPassword(\"MyPassword\", salt); var user = new User(\"MyUsername\", \"myemail@example.com\", passwordHash, salt, new List<string> { \"admin\" }); var userService = serviceProvider.GetRequiredService<IUserService>(); var result = userService.Insert(user); if (result == null) { Console.WriteLine(\"User creation failed: Username or email already exists.\"); } else { Console.WriteLine(\"User created successfully.\"); } 3. Using Role-Based Authorization Use the AuthorizeView component to control access to specific parts of your application based on user roles: <AuthorizeView Roles=\"admin, super admin\"> <Authorized> <p>Admin content visible only to users with 'admin' or 'super admin' roles.</p> </Authorized> <NotAuthorized> <p>You do not have permission to view this content.</p> </NotAuthorized> </AuthorizeView> 4. Managing User Sessions The UserServiceRazor class handles user data persistence within the browser's local storage, ensuring the user's authentication state is preserved across sessions: Persist User to Browser: Saves the user's data securely in the browser's local storage. Fetch User from Browser: Retrieves the user's data from the local storage. Clear User Data: Clears the user's data from the browser, typically used during logout. 5. Authentication State Management The UserAuthenticationStateProvider class extends Blazor's AuthenticationStateProvider to manage the authentication state of users within the application. It interacts with UserServiceRazor for handling user data persistence in the browser. Example: Logging In a User var authProvider = serviceProvider.GetRequiredService<UserAuthenticationStateProvider>(); await authProvider.LoginAsync(\"MyUsername\", \"MyPasswordHash\"); Example: Logging Out a User await authProvider.LogoutAsync(); Security Considerations Password Security: The library uses HMACSHA256 for hashing passwords with unique salts per user, providing a secure method of storing credentials. Protected Local Storage: User data is stored in the browser's protected local storage, offering security enhancements compared to regular local storage. Extending Data Persistence By default, user data is stored in JSON files using UserFileHandler. To use a different storage mechanism, implement the IUserRepository interface and register your implementation: public class CustomUserRepository : IUserRepository { // Implement methods for Save, Update, Delete, and Get users } services.AddSingleton<IUserRepository, CustomUserRepository>(); Contribution Contributions are welcome! Please fork the repository, create a feature branch, and submit a pull request with your changes."
  },
  "src/Lib/Lionk.Auth/README.html": {
    "href": "src/Lib/Lionk.Auth/README.html",
    "title": "Lionk Authentication and Identity Library | Lionk",
    "keywords": "Lionk Authentication and Identity Library Overview The Lionk Authentication and Identity Library provides a comprehensive set of tools for managing user authentication and identity in applications. This library is designed to offer flexible and secure user management, including features for creating, updating, retrieving, and deleting user records, as well as handling password security through hashing and salting mechanisms. The library leverages JSON file-based persistence but can be easily extended to support more robust storage solutions such as databases. Features User Management: Create, update, retrieve, and delete users with the UserService. Password Security: Securely hash passwords and generate salt values using HMACSHA256. Flexible Data Persistence: Use JSON files for storage with the UserFileHandler, which can be replaced by other data handlers without affecting the rest of the application. Role Management: Support for user roles, including assigning and managing roles per user. Claims-Based Authentication: Convert users to and from ClaimsPrincipal for integration with .NET identity and authentication systems. Installation To install the Lionk Authentication and Identity Library, use the NuGet package manager console: Install-Package Lionk.Auth Getting Started 1. Setting Up the UserService The core of the library is the UserService class, which manages all operations related to users. To set up the service in your application, you need to register the required services in the Startup.cs or Program.cs file of your application: using Lionk.Auth.Abstraction; using Lionk.Auth.Identity; // Register services in the container services.AddSingleton<IUserRepository, UserFileHandler>(); services.AddSingleton<IUserService>(sp => new UserService(sp.GetRequiredService<IUserRepository>())); 2. Managing Users With the UserService registered, you can now manage users within your application. Below are some common operations: Creating a User To create a new user, first, hash the password using the PasswordUtils class, then call the Insert method of the UserService: using Lionk.Auth.Identity; using Lionk.Auth.Utils; var salt = PasswordUtils.GenerateSalt(32); var passwordHash = PasswordUtils.HashPassword(\"yourPassword\", salt); var user = new User(\"username\", \"user@example.com\", passwordHash, salt, new List<string> { \"User\" }); var userService = serviceProvider.GetRequiredService<IUserService>(); var insertedUser = userService.Insert(user); if (insertedUser == null) { Console.WriteLine(\"User could not be created. The username or email might already exist.\"); } else { Console.WriteLine(\"User created successfully.\"); } Retrieving a User To retrieve a user by their username or email: var user = userService.GetUserByUsername(\"username\"); if (user != null) { Console.WriteLine($\"User found: {user.Username}\"); } else { Console.WriteLine(\"User not found.\"); } Updating a User Updating a user's details, such as their email or password, can be done by first retrieving the user, modifying the properties, and then calling the Update method: var user = userService.GetUserById(userId); if (user != null) { user.UpdateEmail(\"newemail@example.com\"); userService.Update(user); Console.WriteLine(\"User updated successfully.\"); } else { Console.WriteLine(\"User not found.\"); } Deleting a User To delete a user, simply call the Delete method with the user's ID: var user = userService.GetUserByUsername(\"username\"); if (userService.Delete(user)) { Console.WriteLine(\"User deleted successfully.\"); } else { Console.WriteLine(\"User deletion failed. User might not exist.\"); } Extending Data Persistence By default, the library uses UserFileHandler for JSON file-based storage, but you can implement your own data handler by implementing the IUserRepository interface: public class CustomUserRepository : IUserRepository { public void DeleteUser(User id) { /* Custom implementation */ } public HashSet<User> GetUsers() { /* Custom implementation */ } public void SaveUser(User user) { /* Custom implementation */ } public void UpdateUser(User user) { /* Custom implementation */ } } Register your custom repository in the service container: services.AddSingleton<IUserRepository, CustomUserRepository>(); services.AddSingleton<IUserService>(sp => new UserService(sp.GetRequiredService<IUserRepository>())); Security Considerations Password Hashing: The library uses HMACSHA256 for password hashing, combined with a unique salt per user to enhance security against rainbow table attacks. Role Management: Roles are managed within the user object, allowing easy assignment and validation of permissions. Contribution Contributions are welcome! Please fork the repository, create a branch, and submit a pull request with your enhancements."
  },
  "src/Lib/Lionk.Core.Razor/README.html": {
    "href": "src/Lib/Lionk.Core.Razor/README.html",
    "title": "Lionk.Core.Razor | Lionk",
    "keywords": "Lionk.Core.Razor Lionk.Core.Razor is a Blazor-focused extension of the Lionk.Core library, providing essential components and services for dynamically managing and rendering views in a Blazor application. This library integrates MudBlazor components to create interactive, configurable dialogs and dynamic view handling within Blazor. Overview The Lionk.Core.Razor library focuses on: Dynamic Component Rendering: Allows rendering of components dynamically based on user interactions and context. View Management: Provides services to locate, register, and manage views of components. Dialog Management: Uses MudBlazor dialogs for displaying views with flexible and reusable UI patterns. Installation To use Lionk.Core.Razor in your Blazor project, add the package via NuGet: dotnet add package Lionk.Core.Razor Key Components and Services 1. Dynamic Dialogs The library provides Blazor components for displaying views within MudBlazor dialogs, leveraging MudDialog to present content in a clean and interactive manner. Example: Creating a Dynamic Dialog with a Carousel @using Lionk.Core.Dialog @using Lionk.Core.View <MudDialog Style=\"height:50%\"> <DialogContent> <MudCarousel ShowArrows=\"true\" ShowBullets=\"false\" EnableSwipeGesture=\"true\" AutoCycle=\"false\" TData=\"object\" SelectedIndexChanged=\"ViewChanged\" Style=\"height:100%\" SelectedIndex=\"CurrentIndex\"> @if (ViewDescriptions is not null && ViewDescriptions.Count > 0) { foreach (ComponentViewDescription viewDescription in ViewDescriptions) { <MudCarouselItem Style=\"padding-left:50px; padding-right:50px; overflow-y: scroll;\"> <MudGrid Style=\"width:inherit%\"> <MudItem> <MudText Typo=\"Typo.h6\">@viewDescription.Name</MudText> </MudItem> <MudItem Style=\"width:inherit\"> <DynamicComponentWrapper Type=\"@viewDescription.ViewType\" Parameters=\"_parameter\"/> </MudItem> </MudGrid> </MudCarouselItem> } } </MudCarousel> </DialogContent> <DialogActions> <MudButton OnClick=\"Submit\">Ok</MudButton> </DialogActions> </MudDialog> @code { [CascadingParameter] MudDialogInstance? MudDialog { get; set; } [Parameter] public object? Component { get; set; } [Parameter] public List<ComponentViewDescription>? ViewDescriptions { get; set; } [Parameter] public int CurrentIndex { get; set; } private readonly Dictionary<string, object> _parameter = new(); protected override void OnInitialized() { if (Component is null) return; _parameter.Add(\"Component\", Component); if (CurrentIndex >= ViewDescriptions?.Count) CurrentIndex = 0; } private void Submit() { MudDialog?.Close(DialogResult.Ok(CurrentIndex)); } private void ViewChanged(int index) { CurrentIndex = index; } } Explanation MudDialog: A MudBlazor dialog is used as the main container for the carousel and actions. MudCarousel: Allows navigation between different component views dynamically based on the provided list of ComponentViewDescription. DynamicComponentWrapper: Renders components dynamically based on the ViewType specified in the ComponentViewDescription. 2. Simple Confirmation Dialog Another example of a dialog is a simpler setup for confirmation actions. @namespace Lionk.Core.Dialog <MudDialog> <DialogContent> <MudText>@ContentText</MudText> </DialogContent> <DialogActions> <MudButton OnClick=\"Cancel\">Cancel</MudButton> <MudButton Color=\"@Color\" Variant=\"Variant.Filled\" OnClick=\"Submit\">@ButtonText</MudButton> </DialogActions> </MudDialog> @code { [CascadingParameter] private MudDialogInstance? MudDialog { get; set; } [Parameter] public string? ContentText { get; set; } [Parameter] public string? ButtonText { get; set; } [Parameter] public Color Color { get; set; } private void Submit() { MudDialog?.Close(DialogResult.Ok(true)); } private void Cancel() { MudDialog?.Cancel(); } } 3. View Locator and Registration Services The library includes services for locating and managing views dynamically within Blazor applications: IViewLocatorService Provides methods to locate views associated with specific component types and contexts. Supports different view contexts like configuration, detail, page, and widget views. ViewLocatorService Implements IViewLocatorService to dynamically discover and provide views for components. Uses a types provider (ITypesProvider) to fetch and create views based on defined attributes (ViewOfAttribute). Example: Locating Views for a Component using Lionk.Core.View; public class ExampleComponent { } public void FindViews() { ITypesProvider typesProvider = new CustomTypesProvider(); // Implement ITypesProvider IViewLocatorService viewLocator = new ViewLocatorService(typesProvider); var views = viewLocator.GetViewOf(typeof(ExampleComponent), ViewContext.Detail); foreach (var view in views) { Console.WriteLine($\"View found: {view.Name}, Type: {view.ViewType}\"); } } 4. Dynamic Component Rendering The DynamicComponentWrapper component is used to render views dynamically. It integrates with the IViewRegistryService to manage the lifecycle of dynamically rendered views. Example: Rendering a Dynamic Component @using Lionk.Core.View <DynamicComponentWrapper Type=\"@viewType\" Parameters=\"@viewParameters\" /> @code { [Parameter] public Type? viewType { get; set; } [Parameter] public IDictionary<string, object>? viewParameters { get; set; } } 5. View Registry Service The ViewRegistryService helps in managing active views within the application, allowing checking for active instances and registering or unregistering views dynamically. Example: Using View Registry Service using Lionk.Core.View; var registry = new ViewRegistryService(); // Register a view instance object viewInstance = new CustomView(); registry.Register(viewInstance); // Check if a view type has active instances bool isActive = registry.HasActiveViews(typeof(CustomView)); Console.WriteLine($\"Is CustomView active: {isActive}\"); // Unregister the view instance registry.Unregister(viewInstance); Conclusion Lionk.Core.Razor provides a robust foundation for dynamic component rendering and view management in Blazor applications. By leveraging MudBlazor for UI components and a flexible service architecture for view management, it allows developers to create interactive and configurable user interfaces easily. Contribution Contributions to Lionk.Core are welcome! Please fork the repository, make your changes in a new branch, and submit a pull request."
  },
  "src/Lib/Lionk.Core/README.html": {
    "href": "src/Lib/Lionk.Core/README.html",
    "title": "Lionk.Core | Lionk",
    "keywords": "Here's a detailed and comprehensive README for the Lionk.Core library, focusing on the component part, which is the foundation of the application: Lionk.Core Overview The Lionk.Core library serves as the foundational framework for building modular, reusable, and observable components in the Lionk application. It provides a set of base classes and interfaces for creating components that can be executed, measured, and managed with well-defined life cycles and behaviors. The core functionality includes cyclic execution, error handling, and observable properties, making it suitable for developing complex applications with dynamic and interactive components. Features Modular Component Architecture: Build modular components with well-defined interfaces and base classes. Lifecycle Management: Support for initialization, execution, and termination phases of component life cycles. Cyclic Components: Create components that execute periodically with configurable intervals. Error Handling: Integrated error handling to manage component states and execution flows. Observable Properties: Easily track and respond to changes in component properties. Installation To use the Lionk.Core library in your application, add the following NuGet package: dotnet add package Lionk.Core Getting Started 1. Defining Components Components in Lionk.Core are defined using interfaces and base classes that provide a structured approach to building modular and reusable elements. Below are the key interfaces and classes used in the library: IComponent Interface The IComponent interface defines the basic structure of a component, including a unique identifier and a name: public interface IComponent : IDisposable { Guid Id { get; } string InstanceName { get; set; } } BaseComponent Class BaseComponent is an abstract class implementing IComponent and adding observable property support: public abstract class BaseComponent : ObservableElement, IComponent { public Guid Id { get; set; } = Guid.NewGuid(); public string InstanceName { get; set; } public virtual void Dispose() => GC.SuppressFinalize(this); } 2. Creating Executable Components For components that require execution logic, Lionk.Core provides the IExecutableComponent interface and the BaseExecutableComponent class, which handle execution life cycles, error states, and initialization: IExecutableComponent Interface Defines the execution capabilities for a component: public interface IExecutableComponent : IComponent { bool CanExecute { get; } bool IsInError { get; } bool IsRunning { get; } void Execute(); void Abort(); void Reset(); } BaseExecutableComponent Class Provides a base implementation of IExecutableComponent with methods to manage execution flow and error states: public abstract class BaseExecutableComponent : BaseComponent, IExecutableComponent { public abstract bool CanExecute { get; } public bool IsInError { get; private set; } public bool IsRunning { get; private set; } public void Execute() { // Handles initialization, execution, and termination } public void Abort() { // Handles abort logic and sets the component in error state } public void Reset() { // Resets the component to allow re-execution } protected virtual void OnExecute(CancellationToken cancellationToken) { } protected virtual void OnInitialize() { } protected virtual void OnTerminate() { } } 3. Working with Cyclic Components Cyclic components are those that execute periodically based on a defined time interval. The ICyclicComponent interface and BaseCyclicComponent class provide the necessary functionality: ICyclicComponent Interface Defines the structure for cyclic components with properties for cycle management: public interface ICyclicComponent : IExecutableComponent { CyclicComputationMethod CyclicComputationMethod { get; set; } DateTime LastExecution { get; } int NbCycle { get; } TimeSpan Period { get; set; } DateTime StartedDate { get; } } BaseCyclicComponent Class Provides the base implementation for cyclic components, managing execution cycles and timing: public abstract class BaseCyclicComponent : BaseExecutableComponent, ICyclicComponent { public CyclicComputationMethod CyclicComputationMethod { get; set; } public DateTime LastExecution { get; private set; } public int NbCycle { get; private set; } public TimeSpan Period { get; set; } public DateTime StartedDate { get; private set; } protected override void OnExecute(CancellationToken cancellationToken) { // Increment cycle count and execute component logic } } 4. Observable Components Lionk.Core includes observable elements that notify subscribers of property changes, allowing for dynamic updates and state management across components. ObservableElement Class ObservableElement is a base class that provides property change notification capabilities: public abstract class ObservableElement : INotifyPropertyChanged { protected bool SetField<T>(ref T field, T value, [CallerMemberName] string propertyName = null) { // Updates the field and notifies subscribers } public event PropertyChangedEventHandler PropertyChanged; } 5. Managing Components with ComponentContainer ComponentContainer is a utility class that manages component instances by tracking their unique IDs and handling component availability events. public class ComponentContainer : ObservableElement { private readonly IComponentService _componentService; public IComponent? Component { get; private set; } public Guid ComponentId { get; set; } public event EventHandler? NewComponentAvailable; private void OnNewComponentAvailable() { // Handles logic when a new component becomes available } } Extending Lionk.Core The library is designed to be extensible, allowing developers to create new component types by implementing or extending the provided interfaces and base classes. For example, to create a custom executable component, derive from BaseExecutableComponent and override the necessary methods: public class CustomExecutableComponent : BaseExecutableComponent { public override bool CanExecute => true; protected override void OnExecute(CancellationToken cancellationToken) { // Custom execution logic } } Contribution Contributions to Lionk.Core are welcome! Please fork the repository, make your changes in a new branch, and submit a pull request."
  },
  "src/Lib/Lionk.Logger/README.html": {
    "href": "src/Lib/Lionk.Logger/README.html",
    "title": "Lionk Logger Library | Lionk",
    "keywords": "Lionk Logger Library Overview The Lionk Logger Library provides a robust and flexible logging framework designed to integrate seamlessly into your applications. It offers a standardized approach to logging with varying levels of severity, making it easier to track application behavior, debug issues, and maintain detailed logs. The library supports multiple logging backends and includes a default implementation using Serilog for file-based logging. Features Logger Factory: Easily create loggers with the ILoggerFactory interface, allowing for customized logger implementations. Standard Logging Interface: Use the IStandardLogger interface for consistent logging across different loggers and applications. Configurable Logging: Configure the logging behavior using LogService, including defining log levels and output destinations. Severity Levels: Support for multiple log severity levels, including Trace, Debug, Information, Warning, Error, and Critical. Serilog Integration: Default implementation with Serilog for robust, file-based logging with daily rolling logs. Installation To install the Lionk Logger Library, use the NuGet package manager console: dotnet add package Lionk.Logger Getting Started 1. Setting Up the LogService The core of the library is the LogService class, which manages loggers and provides a straightforward API for logging messages. To set up logging in your application, configure the logger factory in your Startup.cs or Program.cs file: using Lionk.Log; using Lionk.Log.Serilog; // Configure the logger factory var loggerFactory = new SerilogFactory(); LogService.Configure(loggerFactory); 2. Creating and Using Loggers With LogService configured, you can create loggers and start logging messages immediately. Here are some common operations: Creating a Logger To create a new logger, use the CreateLogger method provided by LogService. This method allows you to specify a logger name, which can help categorize logs. using Lionk.Log; // Create a logger for a specific category var logger = LogService.CreateLogger(\"MyAppLogger\"); if (logger != null) { logger.Log(LogSeverity.Information, \"Logger created successfully.\"); } else { Console.WriteLine(\"Failed to create logger.\"); } Logging Messages You can log messages at various severity levels using the Log method of the IStandardLogger interface: logger?.Log(LogSeverity.Debug, \"This is a debug message.\"); logger?.Log(LogSeverity.Information, \"This is an info message.\"); logger?.Log(LogSeverity.Warning, \"This is a warning message.\"); logger?.Log(LogSeverity.Error, \"This is an error message.\"); logger?.Log(LogSeverity.Critical, \"This is a critical message.\"); Logging Application and Debug Messages The LogService also provides specific methods for logging application and debug messages: LogService.LogApp(LogSeverity.Warning, \"This is a warning related to the application.\"); LogService.LogDebug(\"This is a debug message specific to debugging.\"); 3. Configuring Serilog Logging By default, the library uses Serilog for file-based logging. You can customize Serilog configuration by modifying the SerilogFactory class or extending it as needed. using Lionk.Log.Serilog; // Create a custom logger factory if needed var customLoggerFactory = new SerilogFactory(); LogService.Configure(customLoggerFactory); // Log some messages LogService.LogApp(LogSeverity.Information, \"Application has started.\"); LogService.LogDebug(\"Debugging mode is enabled.\"); Extending the Logger The Lionk Logger Library is designed to be easily extensible. You can create custom loggers by implementing the ILoggerFactory and IStandardLogger interfaces: Implementing a Custom Logger using Lionk.Log; public class CustomLoggerFactory : ILoggerFactory { public IStandardLogger CreateLogger(string loggerName) { // Implement custom logger creation logic return new CustomLogger(); } } public class CustomLogger : IStandardLogger { public void Dispose() { // Clean up resources } public void Log(LogSeverity severity, string message) { // Implement custom logging logic Console.WriteLine($\"{severity}: {message}\"); } } Registering Your Custom Logger Replace the default Serilog factory with your custom logger factory: // Use the custom logger factory var customLoggerFactory = new CustomLoggerFactory(); LogService.Configure(customLoggerFactory); // Now LogService will use the custom logger LogService.LogApp(LogSeverity.Information, \"Using custom logger now.\"); Log Severity Levels The library supports multiple log severity levels to categorize log messages effectively: Trace: Detailed information, typically of interest only when diagnosing problems. Debug: Information useful to developers for debugging the application. Information: Informational messages that highlight the progress of the application. Warning: Potentially harmful situations of interest to end users or system managers. Error: Error events of more considerable significance that might still allow the application to continue running. Critical: Severe error events that will presumably lead the application to abort. Security Considerations Log Sanitization: Ensure that sensitive information, such as personal data or authentication details, is not logged. Log Access: Restrict access to log files to maintain confidentiality and integrity. Contribution Contributions are welcome! Please fork the repository, create a branch, and submit a pull request with your enhancements."
  },
  "src/Lib/Lionk.Notification/README.html": {
    "href": "src/Lib/Lionk.Notification/README.html",
    "title": "Notification Library | Lionk",
    "keywords": "Notification Library This library allows sending notifications through various channels, such as email. It also supports the addition of custom channels and recipients. Table of Contents Installation Usage Creating a Notifyer Creating a Notification Using EmailChannel and EmailRecipients NotificationService Implementing New Channels and Recipients Installation Clone the repository. Ensure you have the necessary dependencies Newtonsoft.Json Add the library files to your project. Usage Creating a Notifyer A Notifyer is an entity that sends notifications. You can create a notifyer by implementing the INotifyer interface. public class MyNotifyer : INotifyer { public Guid Id { get; private set; } public string Name { get; private set; } public MyNotifyer(string name) { Id = Guid.NewGuid(); Name = name; } public bool Equals(INotifyer? other) { if (other == null) return false; return Id == other.Id; } } Creating a Notification A notification consists of content (Content) and a notifyer (INotifyer). Content content = new Content(Severity.Information, \"Notification Title\", \"Notification Message\"); INotifyer notifyer = new MyNotifyer(\"MyNotifyer\"); Notification notification = new Notification(content, notifyer); NotificationService.Send(notification); Using EmailChannel and EmailRecipients To send notifications via email, use EmailChannel and EmailRecipients. Create an email recipient: EmailRecipients recipient = new EmailRecipients(\"Recipient Name\", \"email@example.com\"); Create and initialize an email channel: EmailChannel emailChannel = new EmailChannel(\"MyEmailChannel\"); emailChannel.AddRecipients(recipient); emailChannel.Initialize(); Map the notifyer to the channel and send the notification: NotificationService.MapNotifyerToChannel(notifyer, emailChannel); NotificationService.Send(notification); NotificationService The NotificationService class manages notifyers and channels, sends notifications, and maintains notification history. Mapping notifyers to channels is necessary to send notifications. When NotificationService.MapNotifyerToChannel is called, AddChannels and AddNotifyers are called automatically. Adding a Channel To add a channel to the notification service: EmailChannel emailChannel = new EmailChannel(\"MyEmailChannel\"); NotificationService.AddChannels(emailChannel); Adding a Notifyer To add a notifyer to the notification service: INotifyer notifyer = new MyNotifyer(\"MyNotifyer\"); NotificationService.AddNotifyers(notifyer); Mapping Notifyers to Channels To map a notifyer to one or more channels: NotificationService.MapNotifyerToChannel(notifyer, emailChannel); Implementing New Channels and Recipients Implementing a New Channel To create a new type of channel, implement the IChannel interface. public class SmsChannel : IChannel { public Guid Guid { get; private set; } = Guid.NewGuid(); public string Name { get; private set; } public List<IRecipient> Recipients { get; private set; } = new List<IRecipient>(); public bool IsInitialized { get; private set; } = false; public SmsChannel(string name) { Name = name; } public void AddRecipients(params IRecipient[] recipients) { Recipients.AddRange(recipients); } public void Initialize() { // Initialize necessary resources IsInitialized = true; } public void Send(INotifyer notifyer, Content content) { if (!IsInitialized) throw new InvalidOperationException(\"Channel not initialized.\"); // Send the notification via SMS } public bool Equals(object? obj) { return obj is SmsChannel channel && Guid == channel.Guid; } } Implementing a New Recipient To create a new type of recipient, implement the IRecipient interface. public class SmsRecipient : IRecipient { public Guid Guid { get; private set; } = Guid.NewGuid(); public string Name { get; private set; } public string PhoneNumber { get; private set; } public SmsRecipient(string name, string phoneNumber) { Name = name; PhoneNumber = phoneNumber; } } This concludes the documentation for the notification library. For any questions or issues, please open an issue on the repository."
  },
  "src/Lib/Lionk.Plugin.Blazor/README.html": {
    "href": "src/Lib/Lionk.Plugin.Blazor/README.html",
    "title": "Lionk Plugin Blazor Library | Lionk",
    "keywords": "Lionk Plugin Blazor Library Overview The Lionk Plugin Blazor Library provides an interactive and dynamic interface for managing plugins directly within Blazor applications. It includes features for uploading plugins, displaying plugin information, and managing dependencies in a user-friendly manner. This library extends the capabilities of the Lionk Plugin Library by integrating it with Blazor components, allowing seamless plugin management through a web interface. Features File Upload Service: Handles file uploads for plugins, saving them to a specified target directory. Dynamic Plugin Management: View, add, and remove plugins within the Blazor UI. Dependency Visualization: Display and interact with plugin dependencies, showing their load status and allowing for detailed inspection. Responsive UI Components: Utilizes the MudBlazor UI library to provide a responsive and modern interface for managing plugins. Installation To install the Lionk Plugin Blazor Library, use the NuGet package manager console: Install-Package Lionk.Plugin.Blazor Getting Started 1. Setting Up the FileUploadService The FileUploadService is responsible for handling file uploads in the Blazor application. To set up the service, create an instance by specifying the target directory where the files should be saved: using Lionk.Plugin.Blazor; // Initialize FileUploadService with the target directory var fileUploadService = new FileUploadService(\"path/to/target/directory\"); 2. Uploading Files The UploadFileAsync method of the FileUploadService uploads files to the specified directory and returns the new file paths if successful. If a file already exists at the target location, the upload will be canceled: var files = await fileInput.GetMultipleFilesAsync(); // Assume fileInput is a MudBlazor file input component List<string>? uploadedPaths = await fileUploadService.UploadFileAsync(files); if (uploadedPaths != null) { Console.WriteLine(\"Files uploaded successfully:\"); foreach (var path in uploadedPaths) { Console.WriteLine(path); } } else { Console.WriteLine(\"File upload failed. File already exists.\"); } 3. Managing Plugins in Blazor The library provides a Blazor component interface for managing plugins, allowing you to view, add, delete, and inspect plugins directly in the application. The plugin management page and components utilize MudBlazor for a clean and intuitive UI. Displaying Plugins The PluginCard component is used to display details about each plugin, including its name, version, author, description, and dependencies: <PluginCard Plugin=\"@plugin\" OnDependencySelect=\"HandleDependencySelect\" OnDelete=\"DeletePlugin\" /> Handling Plugin Dependencies Dependencies are shown within each plugin card. If a dependency is not loaded, it is displayed with an error icon. Clicking on dependencies triggers further actions like inspecting or resolving issues: <MudCollapse Expanded=\"@ShowDependencies\"> <MudText Typo=\"Typo.caption\">Dependencies:</MudText> <MudList T=\"string\" Class=\"small-font non-selectable\"> @foreach (Dependency dependency in Plugin.Dependencies) { <MudListItem OnClick=\"() => OnDependencySelectAsync(dependency)\"> @if (dependency.IsLoaded) { <MudText>@dependency.AssemblyName.FullName</MudText> } else { <MudText Color=\"Color.Error\">@dependency.AssemblyName.FullName</MudText> } </MudListItem> } </MudList> </MudCollapse> Adding Plugins via File Upload The library supports file uploads directly from the UI using the MudBlazor file upload component: <MudFileUpload T=\"IReadOnlyList<IBrowserFile>\" Accept=\".dll\" OnFilesChanged=\"OnInputFileChanged\"> <ActivatorContent> <MudPaper Height=\"50px\" Outlined=\"true\" Class=\"drag-area\"> <MudText Typo=\"Typo.subtitle2\" Align=\"Align.Center\">Drag files here or click to browse</MudText> <MudButton Color=\"Color.Primary\" Variant=\"Variant.Filled\" OnClick=\"OpenFilePickerAsync\">Browse</MudButton> </MudPaper> </ActivatorContent> </MudFileUpload> Handle the file input event to upload the files and add them as plugins: private async Task OnInputFileChanged(InputFileChangeEventArgs e) { IReadOnlyList<IBrowserFile> files = e.GetMultipleFiles(); List<string>? uploadedPaths = await FileUploadService.UploadFileAsync(files); if (uploadedPaths == null) { Snackbar.Add(\"File upload failed: Plugin with the same name already exists!\", Severity.Error); return; } foreach (string file in uploadedPaths) { PluginManager.AddPlugin(file); Snackbar.Add($\"Plugin {Path.GetFileName(file)} uploaded successfully!\", Severity.Success); } } Deleting Plugins Plugins can be removed from the system using the DeletePlugin method. The UI provides feedback on whether the operation requires an application restart: private void DeletePlugin(Plugin plugin) { PluginManager.RemovePlugin(plugin); Snackbar.Add($\"Plugin {plugin.Name} deleted successfully!\", Severity.Success); StateHasChanged(); } UI Components and Styling The Lionk Plugin Blazor Library uses the MudBlazor component library for UI elements. This integration provides a polished and responsive interface for managing plugins. The components include cards for displaying plugin information, buttons for actions like adding or removing plugins, and dialogs for showing warnings or errors. Customizing the UI The appearance of the plugin management UI can be customized through CSS or by modifying the component parameters. The PluginCard component, for instance, uses MudBlazorÔøΩs MudCard, MudText, and MudButton components, which can be styled via CSS classes or inline styles. Example Plugin Management Page HereÔøΩs a complete example of a plugin management page using Lionk Plugin Blazor: @page \"/plugin-manager\" @inject IPluginManager PluginManager @inject FileUploadService FileUploadService @inject ISnackbar Snackbar <MudStack Style=\"width: 100%\"> <MudAlert Severity=\"Severity.Warning\" Elevation=\"2\" Class=\"mb-4\" Visible=\"@PluginManager.DoNeedARestart()\"> <MudText Typo=\"Typo.subtitle2\" Align=\"Align.Center\"> A restart is required for changes to take effect. Please restart the application. </MudText> </MudAlert> <MudGrid> @foreach (var plugin in PluginManager.GetAllPlugins()) { <MudItem xs=\"12\" sm=\"6\" md=\"4\" lg=\"3\"> <PluginCard Plugin=\"@plugin\" OnDependencySelect=\"HandleDependencySelect\" OnDelete=\"DeletePlugin\" /> </MudItem> } </MudGrid> <MudToolBar> <MudFileUpload T=\"IReadOnlyList<IBrowserFile>\" Accept=\".dll\" OnFilesChanged=\"OnInputFileChanged\"> <ActivatorContent> <MudPaper Class=\"upload-area\"> <MudText Typo=\"Typo.subtitle2\" Align=\"Align.Center\">Drag files here or click to browse</MudText> <MudButton Color=\"Color.Primary\" Variant=\"Variant.Filled\">Browse</MudButton> </MudPaper> </ActivatorContent> </MudFileUpload> </MudToolBar> </MudStack> @code { private async Task OnInputFileChanged(InputFileChangeEventArgs e) { var files = e.GetMultipleFiles(); var result = await FileUploadService.UploadFileAsync(files); if (result != null) { foreach (var path in result) PluginManager.AddPlugin(path); Snackbar.Add(\"Plugins added successfully!\", Severity.Success); } else { Snackbar.Add(\"Failed to upload plugins!\", Severity.Error); } } private void DeletePlugin(Plugin plugin) { PluginManager.RemovePlugin(plugin); Snackbar.Add($\"Plugin {plugin.Name} removed. Restart required.\", Severity.Warning); } private void HandleDependencySelect(Dependency dependency) { // Handle dependency interaction } } Security Considerations File Validation: Ensure that only trusted plugin files are uploaded and loaded by the application to prevent security risks. Dependency Management: Handle dependencies carefully to avoid version conflicts and ensure that all required assemblies are properly loaded. Contribution Contributions to the Lionk Plugin Blazor Library are welcome! Please fork the repository, create a branch, and submit a pull request with your enhancements. For detailed contribution guidelines, please refer to the projectÔøΩs repository."
  },
  "src/Lib/Lionk.Plugin/README.html": {
    "href": "src/Lib/Lionk.Plugin/README.html",
    "title": "Lionk Plugin Library | Lionk",
    "keywords": "Lionk Plugin Library Overview The Lionk Plugin Library provides a comprehensive framework for managing plugins within your applications. It enables dynamic loading, managing dependencies, and controlling plugin lifecycles with ease. The library is designed to enhance application modularity by allowing plugins to be added, removed, or updated without modifying the core application. It supports file-based plugin management using .NET assemblies, offering flexibility for both developers and end-users. Features Plugin Management: Load, manage, and remove plugins dynamically with the PluginManager. Dependency Handling: Automatically manage dependencies between plugins and their assemblies. Plugin Metadata: Access plugin metadata including name, version, author, and description. Persistence: Maintain plugin paths and states across application restarts using JSON configuration files. Type Discovery: Integrate with the applicationÔøΩs type system, providing new types and services as plugins are loaded. Installation To install the Lionk Plugin Library, use the NuGet package manager console: Install-Package Lionk.Plugin Getting Started 1. Setting Up the PluginManager The core of the library is the PluginManager class, which handles all plugin-related operations. To set up the PluginManager in your application, create an instance of it and initialize it as needed: using Lionk.Plugin; // Initialize PluginManager var pluginManager = new PluginManager(); // Optionally, subscribe to new types available event pluginManager.NewTypesAvailable += (sender, args) => { Console.WriteLine(\"New types available:\"); foreach (var type in args.Types) { Console.WriteLine(type.FullName); } }; 2. Managing Plugins With the PluginManager initialized, you can start managing plugins within your application. Here are some common operations: Adding a Plugin To add a new plugin, use the AddPlugin method and provide the path to the plugin assembly (DLL). The method will validate the plugin, load it, and manage its dependencies. pluginManager.AddPlugin(\"path/to/your/plugin.dll\"); Retrieving Loaded Plugins You can retrieve all currently loaded plugins using the GetAllPlugins method, which returns a collection of Plugin objects containing metadata and status information: foreach (var plugin in pluginManager.GetAllPlugins()) { Console.WriteLine($\"Loaded Plugin: {plugin.Name}, Version: {plugin.Version}, Author: {plugin.Author}\"); } Checking If Restart is Needed Some plugin operations might require an application restart, such as removing a plugin. Use the DoNeedARestart method to check if a restart is necessary: if (pluginManager.DoNeedARestart()) { Console.WriteLine(\"A restart is required for changes to take effect.\"); } Removing a Plugin To remove a plugin, use the RemovePlugin method with the specific Plugin object you want to remove. Note that the actual removal will take effect only after the application restarts: var pluginToRemove = pluginManager.GetAllPlugins().FirstOrDefault(p => p.Name == \"PluginName\"); if (pluginToRemove != null) { pluginManager.RemovePlugin(pluginToRemove); Console.WriteLine(\"Plugin scheduled for removal. A restart is required.\"); } 3. Handling Plugin Dependencies The PluginManager automatically handles dependencies between plugins. When loading a plugin, it checks for any required assemblies and attempts to load them. Dependencies are tracked using the Dependency class, which stores information about each required assembly. Example Usage Here's an example demonstrating how to add, list, and remove plugins: using Lionk.Plugin; // Initialize the PluginManager var pluginManager = new PluginManager(); // Add a plugin pluginManager.AddPlugin(\"path/to/plugin.dll\"); // List all plugins Console.WriteLine(\"Loaded Plugins:\"); foreach (var plugin in pluginManager.GetAllPlugins()) { Console.WriteLine($\"Name: {plugin.Name}, Version: {plugin.Version}, Loaded: {plugin.IsLoaded}\"); } // Remove a plugin (requires restart to take effect) var plugin = pluginManager.GetAllPlugins().FirstOrDefault(p => p.Name == \"SomePlugin\"); if (plugin != null) { pluginManager.RemovePlugin(plugin); Console.WriteLine(\"Plugin removed. Restart required to complete the removal.\"); } // Check if restart is required if (pluginManager.DoNeedARestart()) { Console.WriteLine(\"Restart is needed to apply changes.\"); } Plugin Structure and Metadata Each plugin is represented by the Plugin class, which encapsulates the following properties: Assembly: The assembly associated with the plugin. Name: The name of the plugin, extracted from the assemblyÔøΩs metadata. Version: The version of the plugin. Author: The author of the plugin. Description: A brief description of the plugin. Dependencies: A list of dependencies required by the plugin, managed through the Dependency class. Extending Plugin Functionality To extend the plugin management functionality, you can implement custom logic for loading plugins, handling dependencies, or managing plugin configurations by subclassing or modifying the PluginManager. Custom Plugin Manager Example using Lionk.Plugin; public class CustomPluginManager : PluginManager { // Override methods or add new functionalities here protected override void LoadPlugin(string path) { // Custom loading logic base.LoadPlugin(path); } } Security Considerations Plugin Validation: Always validate plugins before loading to ensure they are from trusted sources. Dependency Management: Handle dependencies carefully to avoid version conflicts and security vulnerabilities. Restart Requirements: Be aware that some changes require an application restart to fully apply, especially when dealing with assembly loading and unloading. Contribution Contributions to the Lionk Plugin Library are welcome! Please fork the repository, create a branch, and submit a pull request with your enhancements. For detailed contribution guidelines, please refer to the projectÔøΩs repository."
  },
  "src/Lib/Lionk.Utils/README.html": {
    "href": "src/Lib/Lionk.Utils/README.html",
    "title": "Lionk Configuration Utilities Library | Lionk",
    "keywords": "Lionk Configuration Utilities Library Overview The Lionk Configuration Utilities Library provides a set of utility methods to manage file operations within a defined directory structure for applications. This library is designed to simplify file management tasks such as reading, writing, copying, and deleting files across various designated folders such as configuration, logs, data, and temporary directories. It ensures that these directories are created and managed consistently across the application lifecycle. Features File Management: Perform common file operations like saving, reading, copying, appending, and deleting files. Directory Management: Automatically ensures required directories exist, using predefined folder types. Asynchronous Operations: Support for asynchronous file saving to improve application responsiveness. Error Handling: Built-in error handling for safe file deletions. Installation To install the Lionk Configuration Utilities Library, use the NuGet package manager console: Install-Package Lionk.Utils Getting Started 1. Folder Types The library uses the FolderType enumeration to identify various folders used by the application. These include: Config: Stores configuration files. Logs: Stores log files. Data: Stores data files. Plugin: Stores plugin-related files. Temp: Stores temporary files. These folders are automatically created at the application's base directory upon the first use of the library. 2. Setting Up ConfigurationUtils The ConfigurationUtils class provides static methods for managing files within the predefined folder structure. It uses a dictionary to map each FolderType to its corresponding path within the applicationÔøΩs base directory. Example of Initialization The static constructor ensures that all required directories are created if they do not already exist: using Lionk.Utils; // Directories are created when the class is first accessed ConfigurationUtils.AppendFile(\"example.txt\", \"Hello, World!\", FolderType.Config); 3. Managing Files Saving a File You can save content to a file using the SaveFile method. If the file already exists, it will be overwritten: ConfigurationUtils.SaveFile(\"settings.json\", \"{ 'setting': 'value' }\", FolderType.Config); For asynchronous saving, use: await ConfigurationUtils.SaveFileAsync(\"settings.json\", \"{ 'setting': 'value' }\", FolderType.Config); Reading a File To read the contents of a file, use the ReadFile method. If the file does not exist, an empty string is returned: string configContent = ConfigurationUtils.ReadFile(\"settings.json\", FolderType.Config); Console.WriteLine(configContent); Copying a File Copy a file to one of the predefined folders using the CopyFileToFolder method. This method checks if the destination file already exists before attempting to copy: ConfigurationUtils.CopyFileToFolder(\"sourceFile.txt\", FolderType.Data); Deleting a File You can delete a file with the DeleteFile method. To safely attempt deletion, use TryDeleteFile, which returns a boolean indicating success: ConfigurationUtils.DeleteFile(\"old-config.json\", FolderType.Config); // Attempting safe deletion bool wasDeleted = ConfigurationUtils.TryDeleteFile(\"temp-file.txt\", FolderType.Temp); Console.WriteLine(wasDeleted ? \"File deleted.\" : \"Failed to delete file.\"); Checking if a File Exists Check for the existence of a file using FileExists: bool fileExists = ConfigurationUtils.FileExists(\"log.txt\", FolderType.Logs); Console.WriteLine(fileExists ? \"File exists.\" : \"File does not exist.\"); Appending Content to a File To append content to an existing file or create it if it doesn't exist, use the AppendFile method: ConfigurationUtils.AppendFile(\"log.txt\", \"New log entry\", FolderType.Logs); 4. Directory Management with FileHelper The library includes the FileHelper class, which provides utility methods for managing directories, such as ensuring directories exist: using Lionk.Utils; FileHelper.CreateDirectoryIfNotExists(ConfigurationUtils.GetFolderPath(FolderType.Temp)); Best Practices Error Handling: Use TryDeleteFile for operations where file deletions are not critical to avoid exceptions. Asynchronous Methods: Prefer asynchronous file operations (SaveFileAsync) in scenarios where file I/O might block the main thread or affect application performance. Security Considerations File Path Validation: Always validate file paths to prevent security vulnerabilities such as path traversal attacks. Access Permissions: Ensure the application has appropriate permissions for the file system to perform the required operations in all specified directories. Contribution Contributions are welcome! Please fork the repository, create a branch, and submit a pull request with your improvements or bug fixes. For detailed contribution guidelines, refer to the projectÔøΩs repository."
  }
}